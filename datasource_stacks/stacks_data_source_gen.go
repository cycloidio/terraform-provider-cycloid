// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_stacks

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func StacksDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"organization_canonical": schema.StringAttribute{
				Required:            true,
				Description:         "A canonical of an organization.",
				MarkdownDescription: "A canonical of an organization.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"stacks": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"author": schema.StringAttribute{
							Computed: true,
						},
						"blueprint": schema.BoolAttribute{
							Computed:            true,
							Description:         "Determines if given stack is a blueprint",
							MarkdownDescription: "Determines if given stack is a blueprint",
						},
						"canonical": schema.StringAttribute{
							Computed: true,
						},
						"cloud_providers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"abbreviation": schema.StringAttribute{
										Computed: true,
									},
									"canonical": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"regions": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
								},
								CustomType: CloudProvidersType{
									ObjectType: types.ObjectType{
										AttrTypes: CloudProvidersValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Cloud providers supported by the stack",
							MarkdownDescription: "Cloud providers supported by the stack",
						},
						"dependencies": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"required": schema.BoolAttribute{
										Computed: true,
									},
								},
								CustomType: DependenciesType{
									ObjectType: types.ObjectType{
										AttrTypes: DependenciesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"directory": schema.StringAttribute{
							Computed:            true,
							Description:         "Directory where the stacks configuration is found.",
							MarkdownDescription: "Directory where the stacks configuration is found.",
						},
						"form_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Indicates if this stack can be configured with form's or not. Based on the presence or not of a valid .forms.yaml file since it's creation or last refresh.",
							MarkdownDescription: "Indicates if this stack can be configured with form's or not. Based on the presence or not of a valid .forms.yaml file since it's creation or last refresh.",
						},
						"keywords": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"organization_canonical": schema.StringAttribute{
							Computed:            true,
							Description:         "Organization that the stack belongs to",
							MarkdownDescription: "Organization that the stack belongs to",
						},
						"quota_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Indicates if this stack can be configured with form's and has a Quota configuration.",
							MarkdownDescription: "Indicates if this stack can be configured with form's and has a Quota configuration.",
						},
						"ref": schema.StringAttribute{
							Computed: true,
						},
						"team": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"canonical": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: TeamType{
								ObjectType: types.ObjectType{
									AttrTypes: TeamValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "The entity which represents the information of a team a bit simplified.",
							MarkdownDescription: "The entity which represents the information of a team a bit simplified.",
						},
						"technologies": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"technology": schema.StringAttribute{
										Computed: true,
									},
									"version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: TechnologiesType{
									ObjectType: types.ObjectType{
										AttrTypes: TechnologiesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"trusted": schema.BoolAttribute{
							Computed:            true,
							Description:         "If 'true' the stacks is from the main organization and can be trusted.",
							MarkdownDescription: "If 'true' the stacks is from the main organization and can be trusted.",
						},
						"visibility": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: StacksType{
						ObjectType: types.ObjectType{
							AttrTypes: StacksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type StacksModel struct {
	OrganizationCanonical types.String `tfsdk:"organization_canonical"`
	Stacks                types.List   `tfsdk:"stacks"`
}

var _ basetypes.ObjectTypable = StacksType{}

type StacksType struct {
	basetypes.ObjectType
}

func (t StacksType) Equal(o attr.Type) bool {
	other, ok := o.(StacksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StacksType) String() string {
	return "StacksType"
}

func (t StacksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorAttribute, ok := attributes["author"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`author is missing from object`)

		return nil, diags
	}

	authorVal, ok := authorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`author expected to be basetypes.StringValue, was: %T`, authorAttribute))
	}

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return nil, diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.BoolValue, was: %T`, blueprintAttribute))
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	cloudProvidersAttribute, ok := attributes["cloud_providers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_providers is missing from object`)

		return nil, diags
	}

	cloudProvidersVal, ok := cloudProvidersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_providers expected to be basetypes.ListValue, was: %T`, cloudProvidersAttribute))
	}

	dependenciesAttribute, ok := attributes["dependencies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dependencies is missing from object`)

		return nil, diags
	}

	dependenciesVal, ok := dependenciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dependencies expected to be basetypes.ListValue, was: %T`, dependenciesAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directoryAttribute, ok := attributes["directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directory is missing from object`)

		return nil, diags
	}

	directoryVal, ok := directoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directory expected to be basetypes.StringValue, was: %T`, directoryAttribute))
	}

	formEnabledAttribute, ok := attributes["form_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`form_enabled is missing from object`)

		return nil, diags
	}

	formEnabledVal, ok := formEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`form_enabled expected to be basetypes.BoolValue, was: %T`, formEnabledAttribute))
	}

	keywordsAttribute, ok := attributes["keywords"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywords is missing from object`)

		return nil, diags
	}

	keywordsVal, ok := keywordsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywords expected to be basetypes.ListValue, was: %T`, keywordsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	organizationCanonicalAttribute, ok := attributes["organization_canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_canonical is missing from object`)

		return nil, diags
	}

	organizationCanonicalVal, ok := organizationCanonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_canonical expected to be basetypes.StringValue, was: %T`, organizationCanonicalAttribute))
	}

	quotaEnabledAttribute, ok := attributes["quota_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quota_enabled is missing from object`)

		return nil, diags
	}

	quotaEnabledVal, ok := quotaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quota_enabled expected to be basetypes.BoolValue, was: %T`, quotaEnabledAttribute))
	}

	refAttribute, ok := attributes["ref"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ref is missing from object`)

		return nil, diags
	}

	refVal, ok := refAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ref expected to be basetypes.StringValue, was: %T`, refAttribute))
	}

	teamAttribute, ok := attributes["team"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`team is missing from object`)

		return nil, diags
	}

	teamVal, ok := teamAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`team expected to be basetypes.ObjectValue, was: %T`, teamAttribute))
	}

	technologiesAttribute, ok := attributes["technologies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`technologies is missing from object`)

		return nil, diags
	}

	technologiesVal, ok := technologiesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`technologies expected to be basetypes.ListValue, was: %T`, technologiesAttribute))
	}

	trustedAttribute, ok := attributes["trusted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted is missing from object`)

		return nil, diags
	}

	trustedVal, ok := trustedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted expected to be basetypes.BoolValue, was: %T`, trustedAttribute))
	}

	visibilityAttribute, ok := attributes["visibility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`visibility is missing from object`)

		return nil, diags
	}

	visibilityVal, ok := visibilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`visibility expected to be basetypes.StringValue, was: %T`, visibilityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StacksValue{
		Author:                authorVal,
		Blueprint:             blueprintVal,
		Canonical:             canonicalVal,
		CloudProviders:        cloudProvidersVal,
		Dependencies:          dependenciesVal,
		Description:           descriptionVal,
		Directory:             directoryVal,
		FormEnabled:           formEnabledVal,
		Keywords:              keywordsVal,
		Name:                  nameVal,
		OrganizationCanonical: organizationCanonicalVal,
		QuotaEnabled:          quotaEnabledVal,
		Ref:                   refVal,
		Team:                  teamVal,
		Technologies:          technologiesVal,
		Trusted:               trustedVal,
		Visibility:            visibilityVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStacksValueNull() StacksValue {
	return StacksValue{
		state: attr.ValueStateNull,
	}
}

func NewStacksValueUnknown() StacksValue {
	return StacksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStacksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StacksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StacksValue Attribute Value",
				"While creating a StacksValue value, a missing attribute value was detected. "+
					"A StacksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StacksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StacksValue Attribute Type",
				"While creating a StacksValue value, an invalid attribute value was detected. "+
					"A StacksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StacksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StacksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StacksValue Attribute Value",
				"While creating a StacksValue value, an extra attribute value was detected. "+
					"A StacksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StacksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStacksValueUnknown(), diags
	}

	authorAttribute, ok := attributes["author"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`author is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	authorVal, ok := authorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`author expected to be basetypes.StringValue, was: %T`, authorAttribute))
	}

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.BoolValue, was: %T`, blueprintAttribute))
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	cloudProvidersAttribute, ok := attributes["cloud_providers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_providers is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	cloudProvidersVal, ok := cloudProvidersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_providers expected to be basetypes.ListValue, was: %T`, cloudProvidersAttribute))
	}

	dependenciesAttribute, ok := attributes["dependencies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dependencies is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	dependenciesVal, ok := dependenciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dependencies expected to be basetypes.ListValue, was: %T`, dependenciesAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directoryAttribute, ok := attributes["directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directory is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	directoryVal, ok := directoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directory expected to be basetypes.StringValue, was: %T`, directoryAttribute))
	}

	formEnabledAttribute, ok := attributes["form_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`form_enabled is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	formEnabledVal, ok := formEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`form_enabled expected to be basetypes.BoolValue, was: %T`, formEnabledAttribute))
	}

	keywordsAttribute, ok := attributes["keywords"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywords is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	keywordsVal, ok := keywordsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywords expected to be basetypes.ListValue, was: %T`, keywordsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	organizationCanonicalAttribute, ok := attributes["organization_canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_canonical is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	organizationCanonicalVal, ok := organizationCanonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_canonical expected to be basetypes.StringValue, was: %T`, organizationCanonicalAttribute))
	}

	quotaEnabledAttribute, ok := attributes["quota_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quota_enabled is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	quotaEnabledVal, ok := quotaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quota_enabled expected to be basetypes.BoolValue, was: %T`, quotaEnabledAttribute))
	}

	refAttribute, ok := attributes["ref"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ref is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	refVal, ok := refAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ref expected to be basetypes.StringValue, was: %T`, refAttribute))
	}

	teamAttribute, ok := attributes["team"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`team is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	teamVal, ok := teamAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`team expected to be basetypes.ObjectValue, was: %T`, teamAttribute))
	}

	technologiesAttribute, ok := attributes["technologies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`technologies is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	technologiesVal, ok := technologiesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`technologies expected to be basetypes.ListValue, was: %T`, technologiesAttribute))
	}

	trustedAttribute, ok := attributes["trusted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	trustedVal, ok := trustedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted expected to be basetypes.BoolValue, was: %T`, trustedAttribute))
	}

	visibilityAttribute, ok := attributes["visibility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`visibility is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	visibilityVal, ok := visibilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`visibility expected to be basetypes.StringValue, was: %T`, visibilityAttribute))
	}

	if diags.HasError() {
		return NewStacksValueUnknown(), diags
	}

	return StacksValue{
		Author:                authorVal,
		Blueprint:             blueprintVal,
		Canonical:             canonicalVal,
		CloudProviders:        cloudProvidersVal,
		Dependencies:          dependenciesVal,
		Description:           descriptionVal,
		Directory:             directoryVal,
		FormEnabled:           formEnabledVal,
		Keywords:              keywordsVal,
		Name:                  nameVal,
		OrganizationCanonical: organizationCanonicalVal,
		QuotaEnabled:          quotaEnabledVal,
		Ref:                   refVal,
		Team:                  teamVal,
		Technologies:          technologiesVal,
		Trusted:               trustedVal,
		Visibility:            visibilityVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStacksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StacksValue {
	object, diags := NewStacksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStacksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StacksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStacksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStacksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStacksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStacksValueMust(StacksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StacksType) ValueType(ctx context.Context) attr.Value {
	return StacksValue{}
}

var _ basetypes.ObjectValuable = StacksValue{}

type StacksValue struct {
	Author                basetypes.StringValue `tfsdk:"author"`
	Blueprint             basetypes.BoolValue   `tfsdk:"blueprint"`
	Canonical             basetypes.StringValue `tfsdk:"canonical"`
	CloudProviders        basetypes.ListValue   `tfsdk:"cloud_providers"`
	Dependencies          basetypes.ListValue   `tfsdk:"dependencies"`
	Description           basetypes.StringValue `tfsdk:"description"`
	Directory             basetypes.StringValue `tfsdk:"directory"`
	FormEnabled           basetypes.BoolValue   `tfsdk:"form_enabled"`
	Keywords              basetypes.ListValue   `tfsdk:"keywords"`
	Name                  basetypes.StringValue `tfsdk:"name"`
	OrganizationCanonical basetypes.StringValue `tfsdk:"organization_canonical"`
	QuotaEnabled          basetypes.BoolValue   `tfsdk:"quota_enabled"`
	Ref                   basetypes.StringValue `tfsdk:"ref"`
	Team                  basetypes.ObjectValue `tfsdk:"team"`
	Technologies          basetypes.ListValue   `tfsdk:"technologies"`
	Trusted               basetypes.BoolValue   `tfsdk:"trusted"`
	Visibility            basetypes.StringValue `tfsdk:"visibility"`
	state                 attr.ValueState
}

func (v StacksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["author"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["blueprint"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cloud_providers"] = basetypes.ListType{
		ElemType: CloudProvidersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["dependencies"] = basetypes.ListType{
		ElemType: DependenciesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["directory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["form_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywords"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["organization_canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["quota_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ref"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["team"] = basetypes.ObjectType{
		AttrTypes: TeamValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["technologies"] = basetypes.ListType{
		ElemType: TechnologiesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["trusted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["visibility"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.Author.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["author"] = val

		val, err = v.Blueprint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blueprint"] = val

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.CloudProviders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_providers"] = val

		val, err = v.Dependencies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dependencies"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Directory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["directory"] = val

		val, err = v.FormEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["form_enabled"] = val

		val, err = v.Keywords.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywords"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrganizationCanonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["organization_canonical"] = val

		val, err = v.QuotaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quota_enabled"] = val

		val, err = v.Ref.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ref"] = val

		val, err = v.Team.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["team"] = val

		val, err = v.Technologies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["technologies"] = val

		val, err = v.Trusted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trusted"] = val

		val, err = v.Visibility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["visibility"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StacksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StacksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StacksValue) String() string {
	return "StacksValue"
}

func (v StacksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	cloudProviders := types.ListValueMust(
		CloudProvidersType{
			basetypes.ObjectType{
				AttrTypes: CloudProvidersValue{}.AttributeTypes(ctx),
			},
		},
		v.CloudProviders.Elements(),
	)

	if v.CloudProviders.IsNull() {
		cloudProviders = types.ListNull(
			CloudProvidersType{
				basetypes.ObjectType{
					AttrTypes: CloudProvidersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CloudProviders.IsUnknown() {
		cloudProviders = types.ListUnknown(
			CloudProvidersType{
				basetypes.ObjectType{
					AttrTypes: CloudProvidersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	dependencies := types.ListValueMust(
		DependenciesType{
			basetypes.ObjectType{
				AttrTypes: DependenciesValue{}.AttributeTypes(ctx),
			},
		},
		v.Dependencies.Elements(),
	)

	if v.Dependencies.IsNull() {
		dependencies = types.ListNull(
			DependenciesType{
				basetypes.ObjectType{
					AttrTypes: DependenciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Dependencies.IsUnknown() {
		dependencies = types.ListUnknown(
			DependenciesType{
				basetypes.ObjectType{
					AttrTypes: DependenciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var team basetypes.ObjectValue

	if v.Team.IsNull() {
		team = types.ObjectNull(
			TeamValue{}.AttributeTypes(ctx),
		)
	}

	if v.Team.IsUnknown() {
		team = types.ObjectUnknown(
			TeamValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Team.IsNull() && !v.Team.IsUnknown() {
		team = types.ObjectValueMust(
			TeamValue{}.AttributeTypes(ctx),
			v.Team.Attributes(),
		)
	}

	technologies := types.ListValueMust(
		TechnologiesType{
			basetypes.ObjectType{
				AttrTypes: TechnologiesValue{}.AttributeTypes(ctx),
			},
		},
		v.Technologies.Elements(),
	)

	if v.Technologies.IsNull() {
		technologies = types.ListNull(
			TechnologiesType{
				basetypes.ObjectType{
					AttrTypes: TechnologiesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Technologies.IsUnknown() {
		technologies = types.ListUnknown(
			TechnologiesType{
				basetypes.ObjectType{
					AttrTypes: TechnologiesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var keywordsVal basetypes.ListValue
	switch {
	case v.Keywords.IsUnknown():
		keywordsVal = types.ListUnknown(types.StringType)
	case v.Keywords.IsNull():
		keywordsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		keywordsVal, d = types.ListValue(types.StringType, v.Keywords.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"author":    basetypes.StringType{},
			"blueprint": basetypes.BoolType{},
			"canonical": basetypes.StringType{},
			"cloud_providers": basetypes.ListType{
				ElemType: CloudProvidersValue{}.Type(ctx),
			},
			"dependencies": basetypes.ListType{
				ElemType: DependenciesValue{}.Type(ctx),
			},
			"description":  basetypes.StringType{},
			"directory":    basetypes.StringType{},
			"form_enabled": basetypes.BoolType{},
			"keywords": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name":                   basetypes.StringType{},
			"organization_canonical": basetypes.StringType{},
			"quota_enabled":          basetypes.BoolType{},
			"ref":                    basetypes.StringType{},
			"team": basetypes.ObjectType{
				AttrTypes: TeamValue{}.AttributeTypes(ctx),
			},
			"technologies": basetypes.ListType{
				ElemType: TechnologiesValue{}.Type(ctx),
			},
			"trusted":    basetypes.BoolType{},
			"visibility": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"author":    basetypes.StringType{},
		"blueprint": basetypes.BoolType{},
		"canonical": basetypes.StringType{},
		"cloud_providers": basetypes.ListType{
			ElemType: CloudProvidersValue{}.Type(ctx),
		},
		"dependencies": basetypes.ListType{
			ElemType: DependenciesValue{}.Type(ctx),
		},
		"description":  basetypes.StringType{},
		"directory":    basetypes.StringType{},
		"form_enabled": basetypes.BoolType{},
		"keywords": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name":                   basetypes.StringType{},
		"organization_canonical": basetypes.StringType{},
		"quota_enabled":          basetypes.BoolType{},
		"ref":                    basetypes.StringType{},
		"team": basetypes.ObjectType{
			AttrTypes: TeamValue{}.AttributeTypes(ctx),
		},
		"technologies": basetypes.ListType{
			ElemType: TechnologiesValue{}.Type(ctx),
		},
		"trusted":    basetypes.BoolType{},
		"visibility": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"author":                 v.Author,
			"blueprint":              v.Blueprint,
			"canonical":              v.Canonical,
			"cloud_providers":        cloudProviders,
			"dependencies":           dependencies,
			"description":            v.Description,
			"directory":              v.Directory,
			"form_enabled":           v.FormEnabled,
			"keywords":               keywordsVal,
			"name":                   v.Name,
			"organization_canonical": v.OrganizationCanonical,
			"quota_enabled":          v.QuotaEnabled,
			"ref":                    v.Ref,
			"team":                   team,
			"technologies":           technologies,
			"trusted":                v.Trusted,
			"visibility":             v.Visibility,
		})

	return objVal, diags
}

func (v StacksValue) Equal(o attr.Value) bool {
	other, ok := o.(StacksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Author.Equal(other.Author) {
		return false
	}

	if !v.Blueprint.Equal(other.Blueprint) {
		return false
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.CloudProviders.Equal(other.CloudProviders) {
		return false
	}

	if !v.Dependencies.Equal(other.Dependencies) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Directory.Equal(other.Directory) {
		return false
	}

	if !v.FormEnabled.Equal(other.FormEnabled) {
		return false
	}

	if !v.Keywords.Equal(other.Keywords) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrganizationCanonical.Equal(other.OrganizationCanonical) {
		return false
	}

	if !v.QuotaEnabled.Equal(other.QuotaEnabled) {
		return false
	}

	if !v.Ref.Equal(other.Ref) {
		return false
	}

	if !v.Team.Equal(other.Team) {
		return false
	}

	if !v.Technologies.Equal(other.Technologies) {
		return false
	}

	if !v.Trusted.Equal(other.Trusted) {
		return false
	}

	if !v.Visibility.Equal(other.Visibility) {
		return false
	}

	return true
}

func (v StacksValue) Type(ctx context.Context) attr.Type {
	return StacksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StacksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"author":    basetypes.StringType{},
		"blueprint": basetypes.BoolType{},
		"canonical": basetypes.StringType{},
		"cloud_providers": basetypes.ListType{
			ElemType: CloudProvidersValue{}.Type(ctx),
		},
		"dependencies": basetypes.ListType{
			ElemType: DependenciesValue{}.Type(ctx),
		},
		"description":  basetypes.StringType{},
		"directory":    basetypes.StringType{},
		"form_enabled": basetypes.BoolType{},
		"keywords": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name":                   basetypes.StringType{},
		"organization_canonical": basetypes.StringType{},
		"quota_enabled":          basetypes.BoolType{},
		"ref":                    basetypes.StringType{},
		"team": basetypes.ObjectType{
			AttrTypes: TeamValue{}.AttributeTypes(ctx),
		},
		"technologies": basetypes.ListType{
			ElemType: TechnologiesValue{}.Type(ctx),
		},
		"trusted":    basetypes.BoolType{},
		"visibility": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CloudProvidersType{}

type CloudProvidersType struct {
	basetypes.ObjectType
}

func (t CloudProvidersType) Equal(o attr.Type) bool {
	other, ok := o.(CloudProvidersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CloudProvidersType) String() string {
	return "CloudProvidersType"
}

func (t CloudProvidersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	abbreviationAttribute, ok := attributes["abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`abbreviation is missing from object`)

		return nil, diags
	}

	abbreviationVal, ok := abbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`abbreviation expected to be basetypes.StringValue, was: %T`, abbreviationAttribute))
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return nil, diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CloudProvidersValue{
		Abbreviation: abbreviationVal,
		Canonical:    canonicalVal,
		Name:         nameVal,
		Regions:      regionsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewCloudProvidersValueNull() CloudProvidersValue {
	return CloudProvidersValue{
		state: attr.ValueStateNull,
	}
}

func NewCloudProvidersValueUnknown() CloudProvidersValue {
	return CloudProvidersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCloudProvidersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CloudProvidersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CloudProvidersValue Attribute Value",
				"While creating a CloudProvidersValue value, a missing attribute value was detected. "+
					"A CloudProvidersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudProvidersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CloudProvidersValue Attribute Type",
				"While creating a CloudProvidersValue value, an invalid attribute value was detected. "+
					"A CloudProvidersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudProvidersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CloudProvidersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CloudProvidersValue Attribute Value",
				"While creating a CloudProvidersValue value, an extra attribute value was detected. "+
					"A CloudProvidersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CloudProvidersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCloudProvidersValueUnknown(), diags
	}

	abbreviationAttribute, ok := attributes["abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`abbreviation is missing from object`)

		return NewCloudProvidersValueUnknown(), diags
	}

	abbreviationVal, ok := abbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`abbreviation expected to be basetypes.StringValue, was: %T`, abbreviationAttribute))
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewCloudProvidersValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCloudProvidersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return NewCloudProvidersValueUnknown(), diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	if diags.HasError() {
		return NewCloudProvidersValueUnknown(), diags
	}

	return CloudProvidersValue{
		Abbreviation: abbreviationVal,
		Canonical:    canonicalVal,
		Name:         nameVal,
		Regions:      regionsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewCloudProvidersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CloudProvidersValue {
	object, diags := NewCloudProvidersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCloudProvidersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CloudProvidersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCloudProvidersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCloudProvidersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCloudProvidersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCloudProvidersValueMust(CloudProvidersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CloudProvidersType) ValueType(ctx context.Context) attr.Value {
	return CloudProvidersValue{}
}

var _ basetypes.ObjectValuable = CloudProvidersValue{}

type CloudProvidersValue struct {
	Abbreviation basetypes.StringValue `tfsdk:"abbreviation"`
	Canonical    basetypes.StringValue `tfsdk:"canonical"`
	Name         basetypes.StringValue `tfsdk:"name"`
	Regions      basetypes.ListValue   `tfsdk:"regions"`
	state        attr.ValueState
}

func (v CloudProvidersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["abbreviation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["regions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Abbreviation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["abbreviation"] = val

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Regions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CloudProvidersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CloudProvidersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CloudProvidersValue) String() string {
	return "CloudProvidersValue"
}

func (v CloudProvidersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var regionsVal basetypes.ListValue
	switch {
	case v.Regions.IsUnknown():
		regionsVal = types.ListUnknown(types.StringType)
	case v.Regions.IsNull():
		regionsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		regionsVal, d = types.ListValue(types.StringType, v.Regions.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"abbreviation": basetypes.StringType{},
			"canonical":    basetypes.StringType{},
			"name":         basetypes.StringType{},
			"regions": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"abbreviation": basetypes.StringType{},
		"canonical":    basetypes.StringType{},
		"name":         basetypes.StringType{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"abbreviation": v.Abbreviation,
			"canonical":    v.Canonical,
			"name":         v.Name,
			"regions":      regionsVal,
		})

	return objVal, diags
}

func (v CloudProvidersValue) Equal(o attr.Value) bool {
	other, ok := o.(CloudProvidersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Abbreviation.Equal(other.Abbreviation) {
		return false
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Regions.Equal(other.Regions) {
		return false
	}

	return true
}

func (v CloudProvidersValue) Type(ctx context.Context) attr.Type {
	return CloudProvidersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CloudProvidersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"abbreviation": basetypes.StringType{},
		"canonical":    basetypes.StringType{},
		"name":         basetypes.StringType{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = DependenciesType{}

type DependenciesType struct {
	basetypes.ObjectType
}

func (t DependenciesType) Equal(o attr.Type) bool {
	other, ok := o.(DependenciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DependenciesType) String() string {
	return "DependenciesType"
}

func (t DependenciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	refAttribute, ok := attributes["ref"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ref is missing from object`)

		return nil, diags
	}

	refVal, ok := refAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ref expected to be basetypes.StringValue, was: %T`, refAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return nil, diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DependenciesValue{
		Ref:      refVal,
		Required: requiredVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDependenciesValueNull() DependenciesValue {
	return DependenciesValue{
		state: attr.ValueStateNull,
	}
}

func NewDependenciesValueUnknown() DependenciesValue {
	return DependenciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDependenciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DependenciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DependenciesValue Attribute Value",
				"While creating a DependenciesValue value, a missing attribute value was detected. "+
					"A DependenciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DependenciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DependenciesValue Attribute Type",
				"While creating a DependenciesValue value, an invalid attribute value was detected. "+
					"A DependenciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DependenciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DependenciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DependenciesValue Attribute Value",
				"While creating a DependenciesValue value, an extra attribute value was detected. "+
					"A DependenciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DependenciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDependenciesValueUnknown(), diags
	}

	refAttribute, ok := attributes["ref"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ref is missing from object`)

		return NewDependenciesValueUnknown(), diags
	}

	refVal, ok := refAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ref expected to be basetypes.StringValue, was: %T`, refAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return NewDependenciesValueUnknown(), diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	if diags.HasError() {
		return NewDependenciesValueUnknown(), diags
	}

	return DependenciesValue{
		Ref:      refVal,
		Required: requiredVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDependenciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DependenciesValue {
	object, diags := NewDependenciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDependenciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DependenciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDependenciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDependenciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDependenciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDependenciesValueMust(DependenciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DependenciesType) ValueType(ctx context.Context) attr.Value {
	return DependenciesValue{}
}

var _ basetypes.ObjectValuable = DependenciesValue{}

type DependenciesValue struct {
	Ref      basetypes.StringValue `tfsdk:"ref"`
	Required basetypes.BoolValue   `tfsdk:"required"`
	state    attr.ValueState
}

func (v DependenciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ref"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["required"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ref.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ref"] = val

		val, err = v.Required.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DependenciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DependenciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DependenciesValue) String() string {
	return "DependenciesValue"
}

func (v DependenciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ref":      basetypes.StringType{},
		"required": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ref":      v.Ref,
			"required": v.Required,
		})

	return objVal, diags
}

func (v DependenciesValue) Equal(o attr.Value) bool {
	other, ok := o.(DependenciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ref.Equal(other.Ref) {
		return false
	}

	if !v.Required.Equal(other.Required) {
		return false
	}

	return true
}

func (v DependenciesValue) Type(ctx context.Context) attr.Type {
	return DependenciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DependenciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ref":      basetypes.StringType{},
		"required": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = TeamType{}

type TeamType struct {
	basetypes.ObjectType
}

func (t TeamType) Equal(o attr.Type) bool {
	other, ok := o.(TeamType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TeamType) String() string {
	return "TeamType"
}

func (t TeamType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TeamValue{
		Canonical: canonicalVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTeamValueNull() TeamValue {
	return TeamValue{
		state: attr.ValueStateNull,
	}
}

func NewTeamValueUnknown() TeamValue {
	return TeamValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTeamValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TeamValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TeamValue Attribute Value",
				"While creating a TeamValue value, a missing attribute value was detected. "+
					"A TeamValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TeamValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TeamValue Attribute Type",
				"While creating a TeamValue value, an invalid attribute value was detected. "+
					"A TeamValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TeamValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TeamValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TeamValue Attribute Value",
				"While creating a TeamValue value, an extra attribute value was detected. "+
					"A TeamValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TeamValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTeamValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewTeamValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	if diags.HasError() {
		return NewTeamValueUnknown(), diags
	}

	return TeamValue{
		Canonical: canonicalVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTeamValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TeamValue {
	object, diags := NewTeamValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTeamValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TeamType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTeamValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTeamValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTeamValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTeamValueMust(TeamValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TeamType) ValueType(ctx context.Context) attr.Value {
	return TeamValue{}
}

var _ basetypes.ObjectValuable = TeamValue{}

type TeamValue struct {
	Canonical basetypes.StringValue `tfsdk:"canonical"`
	state     attr.ValueState
}

func (v TeamValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TeamValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TeamValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TeamValue) String() string {
	return "TeamValue"
}

func (v TeamValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"canonical": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"canonical": v.Canonical,
		})

	return objVal, diags
}

func (v TeamValue) Equal(o attr.Value) bool {
	other, ok := o.(TeamValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	return true
}

func (v TeamValue) Type(ctx context.Context) attr.Type {
	return TeamType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TeamValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TechnologiesType{}

type TechnologiesType struct {
	basetypes.ObjectType
}

func (t TechnologiesType) Equal(o attr.Type) bool {
	other, ok := o.(TechnologiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TechnologiesType) String() string {
	return "TechnologiesType"
}

func (t TechnologiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	technologyAttribute, ok := attributes["technology"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`technology is missing from object`)

		return nil, diags
	}

	technologyVal, ok := technologyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`technology expected to be basetypes.StringValue, was: %T`, technologyAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TechnologiesValue{
		Technology: technologyVal,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTechnologiesValueNull() TechnologiesValue {
	return TechnologiesValue{
		state: attr.ValueStateNull,
	}
}

func NewTechnologiesValueUnknown() TechnologiesValue {
	return TechnologiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTechnologiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TechnologiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TechnologiesValue Attribute Value",
				"While creating a TechnologiesValue value, a missing attribute value was detected. "+
					"A TechnologiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TechnologiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TechnologiesValue Attribute Type",
				"While creating a TechnologiesValue value, an invalid attribute value was detected. "+
					"A TechnologiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TechnologiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TechnologiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TechnologiesValue Attribute Value",
				"While creating a TechnologiesValue value, an extra attribute value was detected. "+
					"A TechnologiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TechnologiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTechnologiesValueUnknown(), diags
	}

	technologyAttribute, ok := attributes["technology"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`technology is missing from object`)

		return NewTechnologiesValueUnknown(), diags
	}

	technologyVal, ok := technologyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`technology expected to be basetypes.StringValue, was: %T`, technologyAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewTechnologiesValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewTechnologiesValueUnknown(), diags
	}

	return TechnologiesValue{
		Technology: technologyVal,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTechnologiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TechnologiesValue {
	object, diags := NewTechnologiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTechnologiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TechnologiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTechnologiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTechnologiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTechnologiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTechnologiesValueMust(TechnologiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TechnologiesType) ValueType(ctx context.Context) attr.Value {
	return TechnologiesValue{}
}

var _ basetypes.ObjectValuable = TechnologiesValue{}

type TechnologiesValue struct {
	Technology basetypes.StringValue `tfsdk:"technology"`
	Version    basetypes.StringValue `tfsdk:"version"`
	state      attr.ValueState
}

func (v TechnologiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["technology"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Technology.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["technology"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TechnologiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TechnologiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TechnologiesValue) String() string {
	return "TechnologiesValue"
}

func (v TechnologiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"technology": basetypes.StringType{},
		"version":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"technology": v.Technology,
			"version":    v.Version,
		})

	return objVal, diags
}

func (v TechnologiesValue) Equal(o attr.Value) bool {
	other, ok := o.(TechnologiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Technology.Equal(other.Technology) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v TechnologiesValue) Type(ctx context.Context) attr.Type {
	return TechnologiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TechnologiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"technology": basetypes.StringType{},
		"version":    basetypes.StringType{},
	}
}
