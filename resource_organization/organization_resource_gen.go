// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_organization

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrganizationResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Version: 1,
		Attributes: map[string]schema.Attribute{
			"canonical": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The canonical of an entity",
				MarkdownDescription: "The canonical of an entity",
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"appearance": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"canonical": schema.StringAttribute{
								Computed:            true,
								Description:         "The canonical of an entity",
								MarkdownDescription: "The canonical of an entity",
							},
							"color": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"b": schema.Int64Attribute{
										Computed:            true,
										Description:         "Blue color value of the RGB color",
										MarkdownDescription: "Blue color value of the RGB color",
									},
									"g": schema.Int64Attribute{
										Computed:            true,
										Description:         "Green color value of the RGB color",
										MarkdownDescription: "Green color value of the RGB color",
									},
									"r": schema.Int64Attribute{
										Computed:            true,
										Description:         "Red color value of the RGB color",
										MarkdownDescription: "Red color value of the RGB color",
									},
								},
								CustomType: ColorType{
									ObjectType: types.ObjectType{
										AttrTypes: ColorValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"created_at": schema.Int64Attribute{
								Computed:            true,
								Description:         "The time of creation of the entity",
								MarkdownDescription: "The time of creation of the entity",
							},
							"display_name": schema.StringAttribute{
								Computed: true,
							},
							"favicon": schema.StringAttribute{
								Computed: true,
							},
							"footer": schema.StringAttribute{
								Computed: true,
							},
							"is_active": schema.BoolAttribute{
								Computed: true,
							},
							"logo": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed:            true,
								Description:         "The name of an entity",
								MarkdownDescription: "The name of an entity",
							},
							"tab_title": schema.StringAttribute{
								Computed: true,
							},
							"updated_at": schema.Int64Attribute{
								Computed:            true,
								Description:         "The time of the last update of the entity",
								MarkdownDescription: "The time of the last update of the entity",
							},
						},
						CustomType: AppearanceType{
							ObjectType: types.ObjectType{
								AttrTypes: AppearanceValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "An Appearance holds the values of the branding configuration, which are rendered across an organization",
						MarkdownDescription: "An Appearance holds the values of the branding configuration, which are rendered across an organization",
					},
					"blocked": schema.ListAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"can_children_create_appearance": schema.BoolAttribute{
						Computed: true,
					},
					"can_create_appearance": schema.BoolAttribute{
						Computed: true,
					},
					"canonical": schema.StringAttribute{
						Computed:            true,
						Description:         "The canonical of an entity",
						MarkdownDescription: "The canonical of an entity",
					},
					"ci_port": schema.StringAttribute{
						Computed: true,
					},
					"ci_team_name": schema.StringAttribute{
						Computed: true,
					},
					"ci_url": schema.StringAttribute{
						Computed: true,
					},
					"created_at": schema.Int64Attribute{
						Computed:            true,
						Description:         "The time of creation of the entity",
						MarkdownDescription: "The time of creation of the entity",
					},
					"has_children": schema.BoolAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed:            true,
						Description:         "ID represents the id of the entity",
						MarkdownDescription: "ID represents the id of the entity",
					},
					"mfa_enabled": schema.BoolAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"quotas": schema.BoolAttribute{
						Computed: true,
					},
					"subscription": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"current_members": schema.Int64Attribute{
								Computed: true,
							},
							"expires_at": schema.Int64Attribute{
								Computed: true,
							},
							"members_count": schema.Int64Attribute{
								Computed: true,
							},
							"plan": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"canonical": schema.StringAttribute{
										Computed:            true,
										Description:         "The canonical of an entity",
										MarkdownDescription: "The canonical of an entity",
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: PlanType{
									ObjectType: types.ObjectType{
										AttrTypes: PlanValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "It reflects the Plan used for the subscription",
								MarkdownDescription: "It reflects the Plan used for the subscription",
							},
						},
						CustomType: SubscriptionType{
							ObjectType: types.ObjectType{
								AttrTypes: SubscriptionValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "It reflects the relation between an Organization and a Plan which\ncould be the Free Trial or others, for more info check https://www.cycloid.io/pricing\n",
						MarkdownDescription: "It reflects the relation between an Organization and a Plan which\ncould be the Free Trial or others, for more info check https://www.cycloid.io/pricing\n",
					},
					"updated_at": schema.Int64Attribute{
						Computed:            true,
						Description:         "The time of the last update of the entity",
						MarkdownDescription: "The time of the last update of the entity",
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "The entity which holds all the direct information attached to an organization.",
				MarkdownDescription: "The entity which holds all the direct information attached to an organization.",
			},
			"name": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(3),
				},
			},
			"organization_canonical": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A canonical of an organization.",
				MarkdownDescription: "A canonical of an organization.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
		},
	}
}

type OrganizationModel struct {
	Canonical             types.String `tfsdk:"canonical"`
	Data                  DataValue    `tfsdk:"data"`
	Name                  types.String `tfsdk:"name"`
	OrganizationCanonical types.String `tfsdk:"organization_canonical"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appearanceAttribute, ok := attributes["appearance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appearance is missing from object`)

		return nil, diags
	}

	appearanceVal, ok := appearanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appearance expected to be basetypes.ObjectValue, was: %T`, appearanceAttribute))
	}

	blockedAttribute, ok := attributes["blocked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blocked is missing from object`)

		return nil, diags
	}

	blockedVal, ok := blockedAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blocked expected to be basetypes.ListValue, was: %T`, blockedAttribute))
	}

	canChildrenCreateAppearanceAttribute, ok := attributes["can_children_create_appearance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`can_children_create_appearance is missing from object`)

		return nil, diags
	}

	canChildrenCreateAppearanceVal, ok := canChildrenCreateAppearanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`can_children_create_appearance expected to be basetypes.BoolValue, was: %T`, canChildrenCreateAppearanceAttribute))
	}

	canCreateAppearanceAttribute, ok := attributes["can_create_appearance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`can_create_appearance is missing from object`)

		return nil, diags
	}

	canCreateAppearanceVal, ok := canCreateAppearanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`can_create_appearance expected to be basetypes.BoolValue, was: %T`, canCreateAppearanceAttribute))
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	ciPortAttribute, ok := attributes["ci_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ci_port is missing from object`)

		return nil, diags
	}

	ciPortVal, ok := ciPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ci_port expected to be basetypes.StringValue, was: %T`, ciPortAttribute))
	}

	ciTeamNameAttribute, ok := attributes["ci_team_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ci_team_name is missing from object`)

		return nil, diags
	}

	ciTeamNameVal, ok := ciTeamNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ci_team_name expected to be basetypes.StringValue, was: %T`, ciTeamNameAttribute))
	}

	ciUrlAttribute, ok := attributes["ci_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ci_url is missing from object`)

		return nil, diags
	}

	ciUrlVal, ok := ciUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ci_url expected to be basetypes.StringValue, was: %T`, ciUrlAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.Int64Value, was: %T`, createdAtAttribute))
	}

	hasChildrenAttribute, ok := attributes["has_children"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_children is missing from object`)

		return nil, diags
	}

	hasChildrenVal, ok := hasChildrenAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_children expected to be basetypes.BoolValue, was: %T`, hasChildrenAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	mfaEnabledAttribute, ok := attributes["mfa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mfa_enabled is missing from object`)

		return nil, diags
	}

	mfaEnabledVal, ok := mfaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mfa_enabled expected to be basetypes.BoolValue, was: %T`, mfaEnabledAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	quotasAttribute, ok := attributes["quotas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quotas is missing from object`)

		return nil, diags
	}

	quotasVal, ok := quotasAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quotas expected to be basetypes.BoolValue, was: %T`, quotasAttribute))
	}

	subscriptionAttribute, ok := attributes["subscription"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscription is missing from object`)

		return nil, diags
	}

	subscriptionVal, ok := subscriptionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscription expected to be basetypes.ObjectValue, was: %T`, subscriptionAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.Int64Value, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Appearance:                  appearanceVal,
		Blocked:                     blockedVal,
		CanChildrenCreateAppearance: canChildrenCreateAppearanceVal,
		CanCreateAppearance:         canCreateAppearanceVal,
		Canonical:                   canonicalVal,
		CiPort:                      ciPortVal,
		CiTeamName:                  ciTeamNameVal,
		CiUrl:                       ciUrlVal,
		CreatedAt:                   createdAtVal,
		HasChildren:                 hasChildrenVal,
		Id:                          idVal,
		MfaEnabled:                  mfaEnabledVal,
		Name:                        nameVal,
		Quotas:                      quotasVal,
		Subscription:                subscriptionVal,
		UpdatedAt:                   updatedAtVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	appearanceAttribute, ok := attributes["appearance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appearance is missing from object`)

		return NewDataValueUnknown(), diags
	}

	appearanceVal, ok := appearanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appearance expected to be basetypes.ObjectValue, was: %T`, appearanceAttribute))
	}

	blockedAttribute, ok := attributes["blocked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blocked is missing from object`)

		return NewDataValueUnknown(), diags
	}

	blockedVal, ok := blockedAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blocked expected to be basetypes.ListValue, was: %T`, blockedAttribute))
	}

	canChildrenCreateAppearanceAttribute, ok := attributes["can_children_create_appearance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`can_children_create_appearance is missing from object`)

		return NewDataValueUnknown(), diags
	}

	canChildrenCreateAppearanceVal, ok := canChildrenCreateAppearanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`can_children_create_appearance expected to be basetypes.BoolValue, was: %T`, canChildrenCreateAppearanceAttribute))
	}

	canCreateAppearanceAttribute, ok := attributes["can_create_appearance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`can_create_appearance is missing from object`)

		return NewDataValueUnknown(), diags
	}

	canCreateAppearanceVal, ok := canCreateAppearanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`can_create_appearance expected to be basetypes.BoolValue, was: %T`, canCreateAppearanceAttribute))
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewDataValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	ciPortAttribute, ok := attributes["ci_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ci_port is missing from object`)

		return NewDataValueUnknown(), diags
	}

	ciPortVal, ok := ciPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ci_port expected to be basetypes.StringValue, was: %T`, ciPortAttribute))
	}

	ciTeamNameAttribute, ok := attributes["ci_team_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ci_team_name is missing from object`)

		return NewDataValueUnknown(), diags
	}

	ciTeamNameVal, ok := ciTeamNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ci_team_name expected to be basetypes.StringValue, was: %T`, ciTeamNameAttribute))
	}

	ciUrlAttribute, ok := attributes["ci_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ci_url is missing from object`)

		return NewDataValueUnknown(), diags
	}

	ciUrlVal, ok := ciUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ci_url expected to be basetypes.StringValue, was: %T`, ciUrlAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewDataValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.Int64Value, was: %T`, createdAtAttribute))
	}

	hasChildrenAttribute, ok := attributes["has_children"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_children is missing from object`)

		return NewDataValueUnknown(), diags
	}

	hasChildrenVal, ok := hasChildrenAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_children expected to be basetypes.BoolValue, was: %T`, hasChildrenAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	mfaEnabledAttribute, ok := attributes["mfa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mfa_enabled is missing from object`)

		return NewDataValueUnknown(), diags
	}

	mfaEnabledVal, ok := mfaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mfa_enabled expected to be basetypes.BoolValue, was: %T`, mfaEnabledAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	quotasAttribute, ok := attributes["quotas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quotas is missing from object`)

		return NewDataValueUnknown(), diags
	}

	quotasVal, ok := quotasAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quotas expected to be basetypes.BoolValue, was: %T`, quotasAttribute))
	}

	subscriptionAttribute, ok := attributes["subscription"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscription is missing from object`)

		return NewDataValueUnknown(), diags
	}

	subscriptionVal, ok := subscriptionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscription expected to be basetypes.ObjectValue, was: %T`, subscriptionAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewDataValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.Int64Value, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Appearance:                  appearanceVal,
		Blocked:                     blockedVal,
		CanChildrenCreateAppearance: canChildrenCreateAppearanceVal,
		CanCreateAppearance:         canCreateAppearanceVal,
		Canonical:                   canonicalVal,
		CiPort:                      ciPortVal,
		CiTeamName:                  ciTeamNameVal,
		CiUrl:                       ciUrlVal,
		CreatedAt:                   createdAtVal,
		HasChildren:                 hasChildrenVal,
		Id:                          idVal,
		MfaEnabled:                  mfaEnabledVal,
		Name:                        nameVal,
		Quotas:                      quotasVal,
		Subscription:                subscriptionVal,
		UpdatedAt:                   updatedAtVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Appearance                  basetypes.ObjectValue `tfsdk:"appearance"`
	Blocked                     basetypes.ListValue   `tfsdk:"blocked"`
	CanChildrenCreateAppearance basetypes.BoolValue   `tfsdk:"can_children_create_appearance"`
	CanCreateAppearance         basetypes.BoolValue   `tfsdk:"can_create_appearance"`
	Canonical                   basetypes.StringValue `tfsdk:"canonical"`
	CiPort                      basetypes.StringValue `tfsdk:"ci_port"`
	CiTeamName                  basetypes.StringValue `tfsdk:"ci_team_name"`
	CiUrl                       basetypes.StringValue `tfsdk:"ci_url"`
	CreatedAt                   basetypes.Int64Value  `tfsdk:"created_at"`
	HasChildren                 basetypes.BoolValue   `tfsdk:"has_children"`
	Id                          basetypes.Int64Value  `tfsdk:"id"`
	MfaEnabled                  basetypes.BoolValue   `tfsdk:"mfa_enabled"`
	Name                        basetypes.StringValue `tfsdk:"name"`
	Quotas                      basetypes.BoolValue   `tfsdk:"quotas"`
	Subscription                basetypes.ObjectValue `tfsdk:"subscription"`
	UpdatedAt                   basetypes.Int64Value  `tfsdk:"updated_at"`
	state                       attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["appearance"] = basetypes.ObjectType{
		AttrTypes: AppearanceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["blocked"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["can_children_create_appearance"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["can_create_appearance"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ci_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ci_team_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ci_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["has_children"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mfa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["quotas"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["subscription"] = basetypes.ObjectType{
		AttrTypes: SubscriptionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.Appearance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appearance"] = val

		val, err = v.Blocked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blocked"] = val

		val, err = v.CanChildrenCreateAppearance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["can_children_create_appearance"] = val

		val, err = v.CanCreateAppearance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["can_create_appearance"] = val

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.CiPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ci_port"] = val

		val, err = v.CiTeamName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ci_team_name"] = val

		val, err = v.CiUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ci_url"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.HasChildren.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["has_children"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mfa_enabled"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Quotas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quotas"] = val

		val, err = v.Subscription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subscription"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var appearance basetypes.ObjectValue

	if v.Appearance.IsNull() {
		appearance = types.ObjectNull(
			AppearanceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Appearance.IsUnknown() {
		appearance = types.ObjectUnknown(
			AppearanceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Appearance.IsNull() && !v.Appearance.IsUnknown() {
		appearance = types.ObjectValueMust(
			AppearanceValue{}.AttributeTypes(ctx),
			v.Appearance.Attributes(),
		)
	}

	var subscription basetypes.ObjectValue

	if v.Subscription.IsNull() {
		subscription = types.ObjectNull(
			SubscriptionValue{}.AttributeTypes(ctx),
		)
	}

	if v.Subscription.IsUnknown() {
		subscription = types.ObjectUnknown(
			SubscriptionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Subscription.IsNull() && !v.Subscription.IsUnknown() {
		subscription = types.ObjectValueMust(
			SubscriptionValue{}.AttributeTypes(ctx),
			v.Subscription.Attributes(),
		)
	}

	blockedVal, d := types.ListValue(types.StringType, v.Blocked.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"appearance": basetypes.ObjectType{
				AttrTypes: AppearanceValue{}.AttributeTypes(ctx),
			},
			"blocked": basetypes.ListType{
				ElemType: types.StringType,
			},
			"can_children_create_appearance": basetypes.BoolType{},
			"can_create_appearance":          basetypes.BoolType{},
			"canonical":                      basetypes.StringType{},
			"ci_port":                        basetypes.StringType{},
			"ci_team_name":                   basetypes.StringType{},
			"ci_url":                         basetypes.StringType{},
			"created_at":                     basetypes.Int64Type{},
			"has_children":                   basetypes.BoolType{},
			"id":                             basetypes.Int64Type{},
			"mfa_enabled":                    basetypes.BoolType{},
			"name":                           basetypes.StringType{},
			"quotas":                         basetypes.BoolType{},
			"subscription": basetypes.ObjectType{
				AttrTypes: SubscriptionValue{}.AttributeTypes(ctx),
			},
			"updated_at": basetypes.Int64Type{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"appearance": basetypes.ObjectType{
				AttrTypes: AppearanceValue{}.AttributeTypes(ctx),
			},
			"blocked": basetypes.ListType{
				ElemType: types.StringType,
			},
			"can_children_create_appearance": basetypes.BoolType{},
			"can_create_appearance":          basetypes.BoolType{},
			"canonical":                      basetypes.StringType{},
			"ci_port":                        basetypes.StringType{},
			"ci_team_name":                   basetypes.StringType{},
			"ci_url":                         basetypes.StringType{},
			"created_at":                     basetypes.Int64Type{},
			"has_children":                   basetypes.BoolType{},
			"id":                             basetypes.Int64Type{},
			"mfa_enabled":                    basetypes.BoolType{},
			"name":                           basetypes.StringType{},
			"quotas":                         basetypes.BoolType{},
			"subscription": basetypes.ObjectType{
				AttrTypes: SubscriptionValue{}.AttributeTypes(ctx),
			},
			"updated_at": basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"appearance":                     appearance,
			"blocked":                        blockedVal,
			"can_children_create_appearance": v.CanChildrenCreateAppearance,
			"can_create_appearance":          v.CanCreateAppearance,
			"canonical":                      v.Canonical,
			"ci_port":                        v.CiPort,
			"ci_team_name":                   v.CiTeamName,
			"ci_url":                         v.CiUrl,
			"created_at":                     v.CreatedAt,
			"has_children":                   v.HasChildren,
			"id":                             v.Id,
			"mfa_enabled":                    v.MfaEnabled,
			"name":                           v.Name,
			"quotas":                         v.Quotas,
			"subscription":                   subscription,
			"updated_at":                     v.UpdatedAt,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Appearance.Equal(other.Appearance) {
		return false
	}

	if !v.Blocked.Equal(other.Blocked) {
		return false
	}

	if !v.CanChildrenCreateAppearance.Equal(other.CanChildrenCreateAppearance) {
		return false
	}

	if !v.CanCreateAppearance.Equal(other.CanCreateAppearance) {
		return false
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.CiPort.Equal(other.CiPort) {
		return false
	}

	if !v.CiTeamName.Equal(other.CiTeamName) {
		return false
	}

	if !v.CiUrl.Equal(other.CiUrl) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.HasChildren.Equal(other.HasChildren) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MfaEnabled.Equal(other.MfaEnabled) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Quotas.Equal(other.Quotas) {
		return false
	}

	if !v.Subscription.Equal(other.Subscription) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"appearance": basetypes.ObjectType{
			AttrTypes: AppearanceValue{}.AttributeTypes(ctx),
		},
		"blocked": basetypes.ListType{
			ElemType: types.StringType,
		},
		"can_children_create_appearance": basetypes.BoolType{},
		"can_create_appearance":          basetypes.BoolType{},
		"canonical":                      basetypes.StringType{},
		"ci_port":                        basetypes.StringType{},
		"ci_team_name":                   basetypes.StringType{},
		"ci_url":                         basetypes.StringType{},
		"created_at":                     basetypes.Int64Type{},
		"has_children":                   basetypes.BoolType{},
		"id":                             basetypes.Int64Type{},
		"mfa_enabled":                    basetypes.BoolType{},
		"name":                           basetypes.StringType{},
		"quotas":                         basetypes.BoolType{},
		"subscription": basetypes.ObjectType{
			AttrTypes: SubscriptionValue{}.AttributeTypes(ctx),
		},
		"updated_at": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = AppearanceType{}

type AppearanceType struct {
	basetypes.ObjectType
}

func (t AppearanceType) Equal(o attr.Type) bool {
	other, ok := o.(AppearanceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppearanceType) String() string {
	return "AppearanceType"
}

func (t AppearanceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return nil, diags
	}

	colorVal, ok := colorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.ObjectValue, was: %T`, colorAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.Int64Value, was: %T`, createdAtAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	faviconAttribute, ok := attributes["favicon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`favicon is missing from object`)

		return nil, diags
	}

	faviconVal, ok := faviconAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`favicon expected to be basetypes.StringValue, was: %T`, faviconAttribute))
	}

	footerAttribute, ok := attributes["footer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`footer is missing from object`)

		return nil, diags
	}

	footerVal, ok := footerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`footer expected to be basetypes.StringValue, was: %T`, footerAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return nil, diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	logoAttribute, ok := attributes["logo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo is missing from object`)

		return nil, diags
	}

	logoVal, ok := logoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo expected to be basetypes.StringValue, was: %T`, logoAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tabTitleAttribute, ok := attributes["tab_title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tab_title is missing from object`)

		return nil, diags
	}

	tabTitleVal, ok := tabTitleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tab_title expected to be basetypes.StringValue, was: %T`, tabTitleAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.Int64Value, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppearanceValue{
		Canonical:   canonicalVal,
		Color:       colorVal,
		CreatedAt:   createdAtVal,
		DisplayName: displayNameVal,
		Favicon:     faviconVal,
		Footer:      footerVal,
		IsActive:    isActiveVal,
		Logo:        logoVal,
		Name:        nameVal,
		TabTitle:    tabTitleVal,
		UpdatedAt:   updatedAtVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAppearanceValueNull() AppearanceValue {
	return AppearanceValue{
		state: attr.ValueStateNull,
	}
}

func NewAppearanceValueUnknown() AppearanceValue {
	return AppearanceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppearanceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppearanceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppearanceValue Attribute Value",
				"While creating a AppearanceValue value, a missing attribute value was detected. "+
					"A AppearanceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppearanceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppearanceValue Attribute Type",
				"While creating a AppearanceValue value, an invalid attribute value was detected. "+
					"A AppearanceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppearanceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppearanceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppearanceValue Attribute Value",
				"While creating a AppearanceValue value, an extra attribute value was detected. "+
					"A AppearanceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppearanceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppearanceValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	colorVal, ok := colorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.ObjectValue, was: %T`, colorAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.Int64Value, was: %T`, createdAtAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	faviconAttribute, ok := attributes["favicon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`favicon is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	faviconVal, ok := faviconAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`favicon expected to be basetypes.StringValue, was: %T`, faviconAttribute))
	}

	footerAttribute, ok := attributes["footer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`footer is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	footerVal, ok := footerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`footer expected to be basetypes.StringValue, was: %T`, footerAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	logoAttribute, ok := attributes["logo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	logoVal, ok := logoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo expected to be basetypes.StringValue, was: %T`, logoAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tabTitleAttribute, ok := attributes["tab_title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tab_title is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	tabTitleVal, ok := tabTitleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tab_title expected to be basetypes.StringValue, was: %T`, tabTitleAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewAppearanceValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.Int64Value, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewAppearanceValueUnknown(), diags
	}

	return AppearanceValue{
		Canonical:   canonicalVal,
		Color:       colorVal,
		CreatedAt:   createdAtVal,
		DisplayName: displayNameVal,
		Favicon:     faviconVal,
		Footer:      footerVal,
		IsActive:    isActiveVal,
		Logo:        logoVal,
		Name:        nameVal,
		TabTitle:    tabTitleVal,
		UpdatedAt:   updatedAtVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAppearanceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppearanceValue {
	object, diags := NewAppearanceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppearanceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppearanceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppearanceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppearanceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppearanceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppearanceValueMust(AppearanceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppearanceType) ValueType(ctx context.Context) attr.Value {
	return AppearanceValue{}
}

var _ basetypes.ObjectValuable = AppearanceValue{}

type AppearanceValue struct {
	Canonical   basetypes.StringValue `tfsdk:"canonical"`
	Color       basetypes.ObjectValue `tfsdk:"color"`
	CreatedAt   basetypes.Int64Value  `tfsdk:"created_at"`
	DisplayName basetypes.StringValue `tfsdk:"display_name"`
	Favicon     basetypes.StringValue `tfsdk:"favicon"`
	Footer      basetypes.StringValue `tfsdk:"footer"`
	IsActive    basetypes.BoolValue   `tfsdk:"is_active"`
	Logo        basetypes.StringValue `tfsdk:"logo"`
	Name        basetypes.StringValue `tfsdk:"name"`
	TabTitle    basetypes.StringValue `tfsdk:"tab_title"`
	UpdatedAt   basetypes.Int64Value  `tfsdk:"updated_at"`
	state       attr.ValueState
}

func (v AppearanceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["color"] = basetypes.ObjectType{
		AttrTypes: ColorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["favicon"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["footer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["logo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tab_title"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.Color.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["color"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Favicon.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["favicon"] = val

		val, err = v.Footer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["footer"] = val

		val, err = v.IsActive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_active"] = val

		val, err = v.Logo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["logo"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.TabTitle.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tab_title"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppearanceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppearanceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppearanceValue) String() string {
	return "AppearanceValue"
}

func (v AppearanceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var color basetypes.ObjectValue

	if v.Color.IsNull() {
		color = types.ObjectNull(
			ColorValue{}.AttributeTypes(ctx),
		)
	}

	if v.Color.IsUnknown() {
		color = types.ObjectUnknown(
			ColorValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Color.IsNull() && !v.Color.IsUnknown() {
		color = types.ObjectValueMust(
			ColorValue{}.AttributeTypes(ctx),
			v.Color.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"canonical": basetypes.StringType{},
			"color": basetypes.ObjectType{
				AttrTypes: ColorValue{}.AttributeTypes(ctx),
			},
			"created_at":   basetypes.Int64Type{},
			"display_name": basetypes.StringType{},
			"favicon":      basetypes.StringType{},
			"footer":       basetypes.StringType{},
			"is_active":    basetypes.BoolType{},
			"logo":         basetypes.StringType{},
			"name":         basetypes.StringType{},
			"tab_title":    basetypes.StringType{},
			"updated_at":   basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"canonical":    v.Canonical,
			"color":        color,
			"created_at":   v.CreatedAt,
			"display_name": v.DisplayName,
			"favicon":      v.Favicon,
			"footer":       v.Footer,
			"is_active":    v.IsActive,
			"logo":         v.Logo,
			"name":         v.Name,
			"tab_title":    v.TabTitle,
			"updated_at":   v.UpdatedAt,
		})

	return objVal, diags
}

func (v AppearanceValue) Equal(o attr.Value) bool {
	other, ok := o.(AppearanceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.Color.Equal(other.Color) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Favicon.Equal(other.Favicon) {
		return false
	}

	if !v.Footer.Equal(other.Footer) {
		return false
	}

	if !v.IsActive.Equal(other.IsActive) {
		return false
	}

	if !v.Logo.Equal(other.Logo) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.TabTitle.Equal(other.TabTitle) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v AppearanceValue) Type(ctx context.Context) attr.Type {
	return AppearanceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppearanceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical": basetypes.StringType{},
		"color": basetypes.ObjectType{
			AttrTypes: ColorValue{}.AttributeTypes(ctx),
		},
		"created_at":   basetypes.Int64Type{},
		"display_name": basetypes.StringType{},
		"favicon":      basetypes.StringType{},
		"footer":       basetypes.StringType{},
		"is_active":    basetypes.BoolType{},
		"logo":         basetypes.StringType{},
		"name":         basetypes.StringType{},
		"tab_title":    basetypes.StringType{},
		"updated_at":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ColorType{}

type ColorType struct {
	basetypes.ObjectType
}

func (t ColorType) Equal(o attr.Type) bool {
	other, ok := o.(ColorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ColorType) String() string {
	return "ColorType"
}

func (t ColorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bAttribute, ok := attributes["b"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`b is missing from object`)

		return nil, diags
	}

	bVal, ok := bAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`b expected to be basetypes.Int64Value, was: %T`, bAttribute))
	}

	gAttribute, ok := attributes["g"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`g is missing from object`)

		return nil, diags
	}

	gVal, ok := gAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`g expected to be basetypes.Int64Value, was: %T`, gAttribute))
	}

	rAttribute, ok := attributes["r"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`r is missing from object`)

		return nil, diags
	}

	rVal, ok := rAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`r expected to be basetypes.Int64Value, was: %T`, rAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ColorValue{
		B:     bVal,
		G:     gVal,
		R:     rVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewColorValueNull() ColorValue {
	return ColorValue{
		state: attr.ValueStateNull,
	}
}

func NewColorValueUnknown() ColorValue {
	return ColorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewColorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ColorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ColorValue Attribute Value",
				"While creating a ColorValue value, a missing attribute value was detected. "+
					"A ColorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ColorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ColorValue Attribute Type",
				"While creating a ColorValue value, an invalid attribute value was detected. "+
					"A ColorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ColorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ColorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ColorValue Attribute Value",
				"While creating a ColorValue value, an extra attribute value was detected. "+
					"A ColorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ColorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewColorValueUnknown(), diags
	}

	bAttribute, ok := attributes["b"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`b is missing from object`)

		return NewColorValueUnknown(), diags
	}

	bVal, ok := bAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`b expected to be basetypes.Int64Value, was: %T`, bAttribute))
	}

	gAttribute, ok := attributes["g"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`g is missing from object`)

		return NewColorValueUnknown(), diags
	}

	gVal, ok := gAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`g expected to be basetypes.Int64Value, was: %T`, gAttribute))
	}

	rAttribute, ok := attributes["r"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`r is missing from object`)

		return NewColorValueUnknown(), diags
	}

	rVal, ok := rAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`r expected to be basetypes.Int64Value, was: %T`, rAttribute))
	}

	if diags.HasError() {
		return NewColorValueUnknown(), diags
	}

	return ColorValue{
		B:     bVal,
		G:     gVal,
		R:     rVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewColorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ColorValue {
	object, diags := NewColorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewColorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ColorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewColorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewColorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewColorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewColorValueMust(ColorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ColorType) ValueType(ctx context.Context) attr.Value {
	return ColorValue{}
}

var _ basetypes.ObjectValuable = ColorValue{}

type ColorValue struct {
	B     basetypes.Int64Value `tfsdk:"b"`
	G     basetypes.Int64Value `tfsdk:"g"`
	R     basetypes.Int64Value `tfsdk:"r"`
	state attr.ValueState
}

func (v ColorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["b"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["g"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["r"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.B.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["b"] = val

		val, err = v.G.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["g"] = val

		val, err = v.R.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["r"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ColorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ColorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ColorValue) String() string {
	return "ColorValue"
}

func (v ColorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"b": basetypes.Int64Type{},
			"g": basetypes.Int64Type{},
			"r": basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"b": v.B,
			"g": v.G,
			"r": v.R,
		})

	return objVal, diags
}

func (v ColorValue) Equal(o attr.Value) bool {
	other, ok := o.(ColorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.B.Equal(other.B) {
		return false
	}

	if !v.G.Equal(other.G) {
		return false
	}

	if !v.R.Equal(other.R) {
		return false
	}

	return true
}

func (v ColorValue) Type(ctx context.Context) attr.Type {
	return ColorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ColorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"b": basetypes.Int64Type{},
		"g": basetypes.Int64Type{},
		"r": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SubscriptionType{}

type SubscriptionType struct {
	basetypes.ObjectType
}

func (t SubscriptionType) Equal(o attr.Type) bool {
	other, ok := o.(SubscriptionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubscriptionType) String() string {
	return "SubscriptionType"
}

func (t SubscriptionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentMembersAttribute, ok := attributes["current_members"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_members is missing from object`)

		return nil, diags
	}

	currentMembersVal, ok := currentMembersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_members expected to be basetypes.Int64Value, was: %T`, currentMembersAttribute))
	}

	expiresAtAttribute, ok := attributes["expires_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expires_at is missing from object`)

		return nil, diags
	}

	expiresAtVal, ok := expiresAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expires_at expected to be basetypes.Int64Value, was: %T`, expiresAtAttribute))
	}

	membersCountAttribute, ok := attributes["members_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members_count is missing from object`)

		return nil, diags
	}

	membersCountVal, ok := membersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members_count expected to be basetypes.Int64Value, was: %T`, membersCountAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return nil, diags
	}

	planVal, ok := planAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be basetypes.ObjectValue, was: %T`, planAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubscriptionValue{
		CurrentMembers: currentMembersVal,
		ExpiresAt:      expiresAtVal,
		MembersCount:   membersCountVal,
		Plan:           planVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSubscriptionValueNull() SubscriptionValue {
	return SubscriptionValue{
		state: attr.ValueStateNull,
	}
}

func NewSubscriptionValueUnknown() SubscriptionValue {
	return SubscriptionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubscriptionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubscriptionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubscriptionValue Attribute Value",
				"While creating a SubscriptionValue value, a missing attribute value was detected. "+
					"A SubscriptionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubscriptionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubscriptionValue Attribute Type",
				"While creating a SubscriptionValue value, an invalid attribute value was detected. "+
					"A SubscriptionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubscriptionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubscriptionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubscriptionValue Attribute Value",
				"While creating a SubscriptionValue value, an extra attribute value was detected. "+
					"A SubscriptionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubscriptionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubscriptionValueUnknown(), diags
	}

	currentMembersAttribute, ok := attributes["current_members"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_members is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	currentMembersVal, ok := currentMembersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_members expected to be basetypes.Int64Value, was: %T`, currentMembersAttribute))
	}

	expiresAtAttribute, ok := attributes["expires_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expires_at is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	expiresAtVal, ok := expiresAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expires_at expected to be basetypes.Int64Value, was: %T`, expiresAtAttribute))
	}

	membersCountAttribute, ok := attributes["members_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members_count is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	membersCountVal, ok := membersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members_count expected to be basetypes.Int64Value, was: %T`, membersCountAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	planVal, ok := planAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be basetypes.ObjectValue, was: %T`, planAttribute))
	}

	if diags.HasError() {
		return NewSubscriptionValueUnknown(), diags
	}

	return SubscriptionValue{
		CurrentMembers: currentMembersVal,
		ExpiresAt:      expiresAtVal,
		MembersCount:   membersCountVal,
		Plan:           planVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSubscriptionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubscriptionValue {
	object, diags := NewSubscriptionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubscriptionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubscriptionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubscriptionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubscriptionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubscriptionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubscriptionValueMust(SubscriptionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubscriptionType) ValueType(ctx context.Context) attr.Value {
	return SubscriptionValue{}
}

var _ basetypes.ObjectValuable = SubscriptionValue{}

type SubscriptionValue struct {
	CurrentMembers basetypes.Int64Value  `tfsdk:"current_members"`
	ExpiresAt      basetypes.Int64Value  `tfsdk:"expires_at"`
	MembersCount   basetypes.Int64Value  `tfsdk:"members_count"`
	Plan           basetypes.ObjectValue `tfsdk:"plan"`
	state          attr.ValueState
}

func (v SubscriptionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["current_members"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["expires_at"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["members_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["plan"] = basetypes.ObjectType{
		AttrTypes: PlanValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CurrentMembers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_members"] = val

		val, err = v.ExpiresAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expires_at"] = val

		val, err = v.MembersCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["members_count"] = val

		val, err = v.Plan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubscriptionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubscriptionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubscriptionValue) String() string {
	return "SubscriptionValue"
}

func (v SubscriptionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var plan basetypes.ObjectValue

	if v.Plan.IsNull() {
		plan = types.ObjectNull(
			PlanValue{}.AttributeTypes(ctx),
		)
	}

	if v.Plan.IsUnknown() {
		plan = types.ObjectUnknown(
			PlanValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Plan.IsNull() && !v.Plan.IsUnknown() {
		plan = types.ObjectValueMust(
			PlanValue{}.AttributeTypes(ctx),
			v.Plan.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"current_members": basetypes.Int64Type{},
			"expires_at":      basetypes.Int64Type{},
			"members_count":   basetypes.Int64Type{},
			"plan": basetypes.ObjectType{
				AttrTypes: PlanValue{}.AttributeTypes(ctx),
			},
		},
		map[string]attr.Value{
			"current_members": v.CurrentMembers,
			"expires_at":      v.ExpiresAt,
			"members_count":   v.MembersCount,
			"plan":            plan,
		})

	return objVal, diags
}

func (v SubscriptionValue) Equal(o attr.Value) bool {
	other, ok := o.(SubscriptionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentMembers.Equal(other.CurrentMembers) {
		return false
	}

	if !v.ExpiresAt.Equal(other.ExpiresAt) {
		return false
	}

	if !v.MembersCount.Equal(other.MembersCount) {
		return false
	}

	if !v.Plan.Equal(other.Plan) {
		return false
	}

	return true
}

func (v SubscriptionValue) Type(ctx context.Context) attr.Type {
	return SubscriptionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubscriptionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_members": basetypes.Int64Type{},
		"expires_at":      basetypes.Int64Type{},
		"members_count":   basetypes.Int64Type{},
		"plan": basetypes.ObjectType{
			AttrTypes: PlanValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PlanType{}

type PlanType struct {
	basetypes.ObjectType
}

func (t PlanType) Equal(o attr.Type) bool {
	other, ok := o.(PlanType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlanType) String() string {
	return "PlanType"
}

func (t PlanType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlanValue{
		Canonical: canonicalVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPlanValueNull() PlanValue {
	return PlanValue{
		state: attr.ValueStateNull,
	}
}

func NewPlanValueUnknown() PlanValue {
	return PlanValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlanValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlanValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlanValue Attribute Value",
				"While creating a PlanValue value, a missing attribute value was detected. "+
					"A PlanValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlanValue Attribute Type",
				"While creating a PlanValue value, an invalid attribute value was detected. "+
					"A PlanValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlanValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlanValue Attribute Value",
				"While creating a PlanValue value, an extra attribute value was detected. "+
					"A PlanValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlanValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlanValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewPlanValueUnknown(), diags
	}

	return PlanValue{
		Canonical: canonicalVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPlanValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlanValue {
	object, diags := NewPlanValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlanValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlanType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlanValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlanValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlanValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlanValueMust(PlanValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlanType) ValueType(ctx context.Context) attr.Value {
	return PlanValue{}
}

var _ basetypes.ObjectValuable = PlanValue{}

type PlanValue struct {
	Canonical basetypes.StringValue `tfsdk:"canonical"`
	Name      basetypes.StringValue `tfsdk:"name"`
	state     attr.ValueState
}

func (v PlanValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlanValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlanValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlanValue) String() string {
	return "PlanValue"
}

func (v PlanValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"canonical": basetypes.StringType{},
			"name":      basetypes.StringType{},
		},
		map[string]attr.Value{
			"canonical": v.Canonical,
			"name":      v.Name,
		})

	return objVal, diags
}

func (v PlanValue) Equal(o attr.Value) bool {
	other, ok := o.(PlanValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v PlanValue) Type(ctx context.Context) attr.Type {
	return PlanType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlanValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical": basetypes.StringType{},
		"name":      basetypes.StringType{},
	}
}
