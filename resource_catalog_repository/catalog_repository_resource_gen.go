// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_catalog_repository

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CatalogRepositoryResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"branch": schema.StringAttribute{
				Required: true,
			},
			"canonical": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"credential_canonical": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"branch": schema.StringAttribute{
						Computed: true,
					},
					"canonical": schema.StringAttribute{
						Computed: true,
					},
					"credential_canonical": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"stack_count": schema.Int64Attribute{
						Computed: true,
					},
					"stacks": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"canonical": schema.StringAttribute{
									Computed: true,
								},
								"ref": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: StacksType{
								ObjectType: types.ObjectType{
									AttrTypes: StacksValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "Represents list of service catalogs in the service catalog source. Not used during update action on a service catalog source.",
						MarkdownDescription: "Represents list of service catalogs in the service catalog source. Not used during update action on a service catalog source.",
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"on_create_team": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Team responsible for the maintenance of the underlying service catalogs\n",
				MarkdownDescription: "Team responsible for the maintenance of the underlying service catalogs\n",
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"on_create_visibility": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The visibility setting allows to specify which visibility will be applied to stacks in this catalog repository.\nThis option is only applied during initial catalog repository creation, not for subsequent updates.\n",
				MarkdownDescription: "The visibility setting allows to specify which visibility will be applied to stacks in this catalog repository.\nThis option is only applied during initial catalog repository creation, not for subsequent updates.\n",
			},
			"organization_canonical": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A canonical of an organization.",
				MarkdownDescription: "A canonical of an organization.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"owner": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "User canonical that owns this service catalog source. If omitted then the person\ncreating this service catalog source will be assigned as owner. When a user is the\nowner of a service catalog source they has all the permissions on it.\n",
				MarkdownDescription: "User canonical that owns this service catalog source. If omitted then the person\ncreating this service catalog source will be assigned as owner. When a user is the\nowner of a service catalog source they has all the permissions on it.\n",
			},
			"url": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^((/|~)[^/]*)+.(\\.git)|(([\\w\\]+@[\\w\\.]+))(:(//)?)([\\w\\.@\\:/\\-~]+)(/)?"), ""),
				},
			},
		},
	}
}

type CatalogRepositoryModel struct {
	Branch                types.String `tfsdk:"branch"`
	Canonical             types.String `tfsdk:"canonical"`
	CredentialCanonical   types.String `tfsdk:"credential_canonical"`
	Data                  DataValue    `tfsdk:"data"`
	Name                  types.String `tfsdk:"name"`
	OnCreateTeam          types.String `tfsdk:"on_create_team"`
	OnCreateVisibility    types.String `tfsdk:"on_create_visibility"`
	OrganizationCanonical types.String `tfsdk:"organization_canonical"`
	Owner                 types.String `tfsdk:"owner"`
	Url                   types.String `tfsdk:"url"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	branchAttribute, ok := attributes["branch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`branch is missing from object`)

		return nil, diags
	}

	branchVal, ok := branchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`branch expected to be basetypes.StringValue, was: %T`, branchAttribute))
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	credentialCanonicalAttribute, ok := attributes["credential_canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credential_canonical is missing from object`)

		return nil, diags
	}

	credentialCanonicalVal, ok := credentialCanonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credential_canonical expected to be basetypes.StringValue, was: %T`, credentialCanonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stackCountAttribute, ok := attributes["stack_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stack_count is missing from object`)

		return nil, diags
	}

	stackCountVal, ok := stackCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stack_count expected to be basetypes.Int64Value, was: %T`, stackCountAttribute))
	}

	stacksAttribute, ok := attributes["stacks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stacks is missing from object`)

		return nil, diags
	}

	stacksVal, ok := stacksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stacks expected to be basetypes.ListValue, was: %T`, stacksAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Branch:              branchVal,
		Canonical:           canonicalVal,
		CredentialCanonical: credentialCanonicalVal,
		Name:                nameVal,
		StackCount:          stackCountVal,
		Stacks:              stacksVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	branchAttribute, ok := attributes["branch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`branch is missing from object`)

		return NewDataValueUnknown(), diags
	}

	branchVal, ok := branchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`branch expected to be basetypes.StringValue, was: %T`, branchAttribute))
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewDataValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	credentialCanonicalAttribute, ok := attributes["credential_canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credential_canonical is missing from object`)

		return NewDataValueUnknown(), diags
	}

	credentialCanonicalVal, ok := credentialCanonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credential_canonical expected to be basetypes.StringValue, was: %T`, credentialCanonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stackCountAttribute, ok := attributes["stack_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stack_count is missing from object`)

		return NewDataValueUnknown(), diags
	}

	stackCountVal, ok := stackCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stack_count expected to be basetypes.Int64Value, was: %T`, stackCountAttribute))
	}

	stacksAttribute, ok := attributes["stacks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stacks is missing from object`)

		return NewDataValueUnknown(), diags
	}

	stacksVal, ok := stacksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stacks expected to be basetypes.ListValue, was: %T`, stacksAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewDataValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Branch:              branchVal,
		Canonical:           canonicalVal,
		CredentialCanonical: credentialCanonicalVal,
		Name:                nameVal,
		StackCount:          stackCountVal,
		Stacks:              stacksVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Branch              basetypes.StringValue `tfsdk:"branch"`
	Canonical           basetypes.StringValue `tfsdk:"canonical"`
	CredentialCanonical basetypes.StringValue `tfsdk:"credential_canonical"`
	Name                basetypes.StringValue `tfsdk:"name"`
	StackCount          basetypes.Int64Value  `tfsdk:"stack_count"`
	Stacks              basetypes.ListValue   `tfsdk:"stacks"`
	Url                 basetypes.StringValue `tfsdk:"url"`
	state               attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["branch"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["credential_canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stack_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["stacks"] = basetypes.ListType{
		ElemType: StacksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Branch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["branch"] = val

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.CredentialCanonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credential_canonical"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.StackCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stack_count"] = val

		val, err = v.Stacks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stacks"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	stacks := types.ListValueMust(
		StacksType{
			basetypes.ObjectType{
				AttrTypes: StacksValue{}.AttributeTypes(ctx),
			},
		},
		v.Stacks.Elements(),
	)

	if v.Stacks.IsNull() {
		stacks = types.ListNull(
			StacksType{
				basetypes.ObjectType{
					AttrTypes: StacksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Stacks.IsUnknown() {
		stacks = types.ListUnknown(
			StacksType{
				basetypes.ObjectType{
					AttrTypes: StacksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"branch":               basetypes.StringType{},
		"canonical":            basetypes.StringType{},
		"credential_canonical": basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"stack_count":          basetypes.Int64Type{},
		"stacks": basetypes.ListType{
			ElemType: StacksValue{}.Type(ctx),
		},
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"branch":               v.Branch,
			"canonical":            v.Canonical,
			"credential_canonical": v.CredentialCanonical,
			"name":                 v.Name,
			"stack_count":          v.StackCount,
			"stacks":               stacks,
			"url":                  v.Url,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Branch.Equal(other.Branch) {
		return false
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.CredentialCanonical.Equal(other.CredentialCanonical) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.StackCount.Equal(other.StackCount) {
		return false
	}

	if !v.Stacks.Equal(other.Stacks) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"branch":               basetypes.StringType{},
		"canonical":            basetypes.StringType{},
		"credential_canonical": basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"stack_count":          basetypes.Int64Type{},
		"stacks": basetypes.ListType{
			ElemType: StacksValue{}.Type(ctx),
		},
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StacksType{}

type StacksType struct {
	basetypes.ObjectType
}

func (t StacksType) Equal(o attr.Type) bool {
	other, ok := o.(StacksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StacksType) String() string {
	return "StacksType"
}

func (t StacksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	refAttribute, ok := attributes["ref"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ref is missing from object`)

		return nil, diags
	}

	refVal, ok := refAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ref expected to be basetypes.StringValue, was: %T`, refAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StacksValue{
		Canonical: canonicalVal,
		Ref:       refVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStacksValueNull() StacksValue {
	return StacksValue{
		state: attr.ValueStateNull,
	}
}

func NewStacksValueUnknown() StacksValue {
	return StacksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStacksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StacksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StacksValue Attribute Value",
				"While creating a StacksValue value, a missing attribute value was detected. "+
					"A StacksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StacksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StacksValue Attribute Type",
				"While creating a StacksValue value, an invalid attribute value was detected. "+
					"A StacksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StacksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StacksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StacksValue Attribute Value",
				"While creating a StacksValue value, an extra attribute value was detected. "+
					"A StacksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StacksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStacksValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	refAttribute, ok := attributes["ref"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ref is missing from object`)

		return NewStacksValueUnknown(), diags
	}

	refVal, ok := refAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ref expected to be basetypes.StringValue, was: %T`, refAttribute))
	}

	if diags.HasError() {
		return NewStacksValueUnknown(), diags
	}

	return StacksValue{
		Canonical: canonicalVal,
		Ref:       refVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStacksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StacksValue {
	object, diags := NewStacksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStacksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StacksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStacksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStacksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStacksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStacksValueMust(StacksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StacksType) ValueType(ctx context.Context) attr.Value {
	return StacksValue{}
}

var _ basetypes.ObjectValuable = StacksValue{}

type StacksValue struct {
	Canonical basetypes.StringValue `tfsdk:"canonical"`
	Ref       basetypes.StringValue `tfsdk:"ref"`
	state     attr.ValueState
}

func (v StacksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ref"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.Ref.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ref"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StacksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StacksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StacksValue) String() string {
	return "StacksValue"
}

func (v StacksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"canonical": basetypes.StringType{},
		"ref":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"canonical": v.Canonical,
			"ref":       v.Ref,
		})

	return objVal, diags
}

func (v StacksValue) Equal(o attr.Value) bool {
	other, ok := o.(StacksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.Ref.Equal(other.Ref) {
		return false
	}

	return true
}

func (v StacksValue) Type(ctx context.Context) attr.Type {
	return StacksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StacksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical": basetypes.StringType{},
		"ref":       basetypes.StringType{},
	}
}
