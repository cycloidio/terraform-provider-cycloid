// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_credential

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CredentialResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"canonical": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"credential_canonical": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A Credential canonical",
				MarkdownDescription: "A Credential canonical",
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"canonical": schema.StringAttribute{
						Computed: true,
					},
					"created_at": schema.Int64Attribute{
						Computed: true,
					},
					"description": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"in_use": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"config_repositories": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"canonical": schema.StringAttribute{
											Computed: true,
										},
										"name": schema.StringAttribute{
											Computed: true,
										},
									},
									CustomType: ConfigRepositoriesType{
										ObjectType: types.ObjectType{
											AttrTypes: ConfigRepositoriesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed: true,
							},
							"external_backends": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"engine": schema.StringAttribute{
											Computed: true,
										},
										"environment": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"canonical": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: EnvironmentType{
												ObjectType: types.ObjectType{
													AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
												},
											},
											Computed:            true,
											Description:         "Represents an environment that's using credential",
											MarkdownDescription: "Represents an environment that's using credential",
										},
										"project": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"canonical": schema.StringAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: ProjectType{
												ObjectType: types.ObjectType{
													AttrTypes: ProjectValue{}.AttributeTypes(ctx),
												},
											},
											Computed:            true,
											Description:         "Represents a project that's using credential",
											MarkdownDescription: "Represents a project that's using credential",
										},
										"purpose": schema.StringAttribute{
											Computed: true,
										},
									},
									CustomType: ExternalBackendsType{
										ObjectType: types.ObjectType{
											AttrTypes: ExternalBackendsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed: true,
							},
							"service_catalog_sources": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"canonical": schema.StringAttribute{
											Computed: true,
										},
										"name": schema.StringAttribute{
											Computed: true,
										},
									},
									CustomType: ServiceCatalogSourcesType{
										ObjectType: types.ObjectType{
											AttrTypes: ServiceCatalogSourcesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed: true,
							},
						},
						CustomType: InUseType{
							ObjectType: types.ObjectType{
								AttrTypes: InUseValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "InUse represents the resources that are using provided credential.\n",
						MarkdownDescription: "InUse represents the resources that are using provided credential.\n",
					},
					"keys": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "List of all the keys available for the Credential",
						MarkdownDescription: "List of all the keys available for the Credential",
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"owner": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"country_code": schema.StringAttribute{
								Computed:            true,
								Description:         "Code of a country the user is from",
								MarkdownDescription: "Code of a country the user is from",
							},
							"created_at": schema.Int64Attribute{
								Computed:            true,
								Description:         "When the user became a member.",
								MarkdownDescription: "When the user became a member.",
							},
							"email": schema.StringAttribute{
								Computed:            true,
								Description:         "User's primary email.",
								MarkdownDescription: "User's primary email.",
							},
							"family_name": schema.StringAttribute{
								Computed: true,
							},
							"given_name": schema.StringAttribute{
								Computed: true,
							},
							"id": schema.Int64Attribute{
								Computed: true,
							},
							"last_login_at": schema.Int64Attribute{
								Computed:            true,
								Description:         "When the user logged in last time.",
								MarkdownDescription: "When the user logged in last time.",
							},
							"locale": schema.StringAttribute{
								Computed:            true,
								Description:         "The local that the user prefer.",
								MarkdownDescription: "The local that the user prefer.",
							},
							"mfa_enabled": schema.BoolAttribute{
								Computed: true,
							},
							"picture_url": schema.StringAttribute{
								Computed: true,
							},
							"updated_at": schema.Int64Attribute{
								Computed:            true,
								Description:         "When the user had the role modified.",
								MarkdownDescription: "When the user had the role modified.",
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						CustomType: OwnerType{
							ObjectType: types.ObjectType{
								AttrTypes: OwnerValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "A summary of a user to be used in places where only the basic information are need or are enough.",
						MarkdownDescription: "A summary of a user to be used in places where only the basic information are need or are enough.",
					},
					"path": schema.StringAttribute{
						Computed: true,
					},
					"raw": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"access_key": schema.StringAttribute{
								Computed: true,
							},
							"account_name": schema.StringAttribute{
								Computed: true,
							},
							"auth_url": schema.StringAttribute{
								Computed: true,
							},
							"ca_cert": schema.StringAttribute{
								Computed: true,
							},
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"domain_id": schema.StringAttribute{
								Computed: true,
							},
							"json_key": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"raw": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{},
								CustomType: RawType{
									ObjectType: types.ObjectType{
										AttrTypes: RawValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"secret_key": schema.StringAttribute{
								Computed: true,
							},
							"ssh_key": schema.StringAttribute{
								Computed: true,
							},
							"subscription_id": schema.StringAttribute{
								Computed: true,
							},
							"tenant_id": schema.StringAttribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						CustomType: RawType{
							ObjectType: types.ObjectType{
								AttrTypes: RawValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "All the possible fields inside it",
						MarkdownDescription: "All the possible fields inside it",
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
					"updated_at": schema.Int64Attribute{
						Computed: true,
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Represents the Credential",
				MarkdownDescription: "Represents the Credential",
			},
			"description": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"organization_canonical": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A canonical of an organization.",
				MarkdownDescription: "A canonical of an organization.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(3, 100),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]+[a-z0-9\\-_]+[a-z0-9]+$"), ""),
				},
			},
			"owner": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "User canonical that owns this credential. If omitted then the person creating this\ncredential will be assigned as owner. When a user is the owner of a credential he has\nall the permissions on it.\n",
				MarkdownDescription: "User canonical that owns this credential. If omitted then the person creating this\ncredential will be assigned as owner. When a user is the owner of a credential he has\nall the permissions on it.\n",
			},
			"path": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("[a-zA-z0-9_\\-./]"), ""),
				},
			},
			"raw": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"access_key": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"account_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"auth_url": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"ca_cert": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"client_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"client_secret": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"domain_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"json_key": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"password": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"raw": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{},
						CustomType: RawType{
							ObjectType: types.ObjectType{
								AttrTypes: RawValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"secret_key": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"ssh_key": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"subscription_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"tenant_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"username": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: RawType{
					ObjectType: types.ObjectType{
						AttrTypes: RawValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "All the possible fields inside it",
				MarkdownDescription: "All the possible fields inside it",
			},
			"type": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"ssh",
						"aws",
						"custom",
						"azure",
						"azure_storage",
						"gcp",
						"basic_auth",
						"elasticsearch",
						"swift",
						"vmware",
					),
				},
			},
		},
	}
}

type CredentialModel struct {
	Canonical             types.String `tfsdk:"canonical"`
	CredentialCanonical   types.String `tfsdk:"credential_canonical"`
	Data                  DataValue    `tfsdk:"data"`
	Description           types.String `tfsdk:"description"`
	Name                  types.String `tfsdk:"name"`
	OrganizationCanonical types.String `tfsdk:"organization_canonical"`
	Owner                 types.String `tfsdk:"owner"`
	Path                  types.String `tfsdk:"path"`
	Raw                   RawValue     `tfsdk:"raw"`
	Type                  types.String `tfsdk:"type"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.Int64Value, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	inUseAttribute, ok := attributes["in_use"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in_use is missing from object`)

		return nil, diags
	}

	inUseVal, ok := inUseAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in_use expected to be basetypes.ObjectValue, was: %T`, inUseAttribute))
	}

	keysAttribute, ok := attributes["keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keys is missing from object`)

		return nil, diags
	}

	keysVal, ok := keysAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keys expected to be basetypes.ListValue, was: %T`, keysAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ownerAttribute, ok := attributes["owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`owner is missing from object`)

		return nil, diags
	}

	ownerVal, ok := ownerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`owner expected to be basetypes.ObjectValue, was: %T`, ownerAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	rawAttribute, ok := attributes["raw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raw is missing from object`)

		return nil, diags
	}

	rawVal, ok := rawAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raw expected to be basetypes.ObjectValue, was: %T`, rawAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.Int64Value, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Canonical:   canonicalVal,
		CreatedAt:   createdAtVal,
		Description: descriptionVal,
		Id:          idVal,
		InUse:       inUseVal,
		Keys:        keysVal,
		Name:        nameVal,
		Owner:       ownerVal,
		Path:        pathVal,
		Raw:         rawVal,
		DataType:    typeVal,
		UpdatedAt:   updatedAtVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewDataValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewDataValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.Int64Value, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewDataValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	inUseAttribute, ok := attributes["in_use"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in_use is missing from object`)

		return NewDataValueUnknown(), diags
	}

	inUseVal, ok := inUseAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in_use expected to be basetypes.ObjectValue, was: %T`, inUseAttribute))
	}

	keysAttribute, ok := attributes["keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keys is missing from object`)

		return NewDataValueUnknown(), diags
	}

	keysVal, ok := keysAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keys expected to be basetypes.ListValue, was: %T`, keysAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ownerAttribute, ok := attributes["owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`owner is missing from object`)

		return NewDataValueUnknown(), diags
	}

	ownerVal, ok := ownerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`owner expected to be basetypes.ObjectValue, was: %T`, ownerAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewDataValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	rawAttribute, ok := attributes["raw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raw is missing from object`)

		return NewDataValueUnknown(), diags
	}

	rawVal, ok := rawAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raw expected to be basetypes.ObjectValue, was: %T`, rawAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewDataValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.Int64Value, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Canonical:   canonicalVal,
		CreatedAt:   createdAtVal,
		Description: descriptionVal,
		Id:          idVal,
		InUse:       inUseVal,
		Keys:        keysVal,
		Name:        nameVal,
		Owner:       ownerVal,
		Path:        pathVal,
		Raw:         rawVal,
		DataType:    typeVal,
		UpdatedAt:   updatedAtVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Canonical   basetypes.StringValue `tfsdk:"canonical"`
	CreatedAt   basetypes.Int64Value  `tfsdk:"created_at"`
	Description basetypes.StringValue `tfsdk:"description"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	InUse       basetypes.ObjectValue `tfsdk:"in_use"`
	Keys        basetypes.ListValue   `tfsdk:"keys"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Owner       basetypes.ObjectValue `tfsdk:"owner"`
	Path        basetypes.StringValue `tfsdk:"path"`
	Raw         basetypes.ObjectValue `tfsdk:"raw"`
	DataType    basetypes.StringValue `tfsdk:"type"`
	UpdatedAt   basetypes.Int64Value  `tfsdk:"updated_at"`
	state       attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["in_use"] = basetypes.ObjectType{
		AttrTypes: InUseValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["keys"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["owner"] = basetypes.ObjectType{
		AttrTypes: OwnerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["raw"] = basetypes.ObjectType{
		AttrTypes: RawValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.InUse.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["in_use"] = val

		val, err = v.Keys.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keys"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Owner.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["owner"] = val

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Raw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["raw"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var inUse basetypes.ObjectValue

	if v.InUse.IsNull() {
		inUse = types.ObjectNull(
			InUseValue{}.AttributeTypes(ctx),
		)
	}

	if v.InUse.IsUnknown() {
		inUse = types.ObjectUnknown(
			InUseValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InUse.IsNull() && !v.InUse.IsUnknown() {
		inUse = types.ObjectValueMust(
			InUseValue{}.AttributeTypes(ctx),
			v.InUse.Attributes(),
		)
	}

	var owner basetypes.ObjectValue

	if v.Owner.IsNull() {
		owner = types.ObjectNull(
			OwnerValue{}.AttributeTypes(ctx),
		)
	}

	if v.Owner.IsUnknown() {
		owner = types.ObjectUnknown(
			OwnerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Owner.IsNull() && !v.Owner.IsUnknown() {
		owner = types.ObjectValueMust(
			OwnerValue{}.AttributeTypes(ctx),
			v.Owner.Attributes(),
		)
	}

	var raw basetypes.ObjectValue

	if v.Raw.IsNull() {
		raw = types.ObjectNull(
			RawValue{}.AttributeTypes(ctx),
		)
	}

	if v.Raw.IsUnknown() {
		raw = types.ObjectUnknown(
			RawValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Raw.IsNull() && !v.Raw.IsUnknown() {
		raw = types.ObjectValueMust(
			RawValue{}.AttributeTypes(ctx),
			v.Raw.Attributes(),
		)
	}

	keysVal, d := types.ListValue(types.StringType, v.Keys.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"canonical":   basetypes.StringType{},
			"created_at":  basetypes.Int64Type{},
			"description": basetypes.StringType{},
			"id":          basetypes.Int64Type{},
			"in_use": basetypes.ObjectType{
				AttrTypes: InUseValue{}.AttributeTypes(ctx),
			},
			"keys": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"owner": basetypes.ObjectType{
				AttrTypes: OwnerValue{}.AttributeTypes(ctx),
			},
			"path": basetypes.StringType{},
			"raw": basetypes.ObjectType{
				AttrTypes: RawValue{}.AttributeTypes(ctx),
			},
			"type":       basetypes.StringType{},
			"updated_at": basetypes.Int64Type{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"canonical":   basetypes.StringType{},
			"created_at":  basetypes.Int64Type{},
			"description": basetypes.StringType{},
			"id":          basetypes.Int64Type{},
			"in_use": basetypes.ObjectType{
				AttrTypes: InUseValue{}.AttributeTypes(ctx),
			},
			"keys": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"owner": basetypes.ObjectType{
				AttrTypes: OwnerValue{}.AttributeTypes(ctx),
			},
			"path": basetypes.StringType{},
			"raw": basetypes.ObjectType{
				AttrTypes: RawValue{}.AttributeTypes(ctx),
			},
			"type":       basetypes.StringType{},
			"updated_at": basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"canonical":   v.Canonical,
			"created_at":  v.CreatedAt,
			"description": v.Description,
			"id":          v.Id,
			"in_use":      inUse,
			"keys":        keysVal,
			"name":        v.Name,
			"owner":       owner,
			"path":        v.Path,
			"raw":         raw,
			"type":        v.DataType,
			"updated_at":  v.UpdatedAt,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.InUse.Equal(other.InUse) {
		return false
	}

	if !v.Keys.Equal(other.Keys) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Owner.Equal(other.Owner) {
		return false
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Raw.Equal(other.Raw) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical":   basetypes.StringType{},
		"created_at":  basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"in_use": basetypes.ObjectType{
			AttrTypes: InUseValue{}.AttributeTypes(ctx),
		},
		"keys": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
		"owner": basetypes.ObjectType{
			AttrTypes: OwnerValue{}.AttributeTypes(ctx),
		},
		"path": basetypes.StringType{},
		"raw": basetypes.ObjectType{
			AttrTypes: RawValue{}.AttributeTypes(ctx),
		},
		"type":       basetypes.StringType{},
		"updated_at": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = InUseType{}

type InUseType struct {
	basetypes.ObjectType
}

func (t InUseType) Equal(o attr.Type) bool {
	other, ok := o.(InUseType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InUseType) String() string {
	return "InUseType"
}

func (t InUseType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configRepositoriesAttribute, ok := attributes["config_repositories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_repositories is missing from object`)

		return nil, diags
	}

	configRepositoriesVal, ok := configRepositoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_repositories expected to be basetypes.ListValue, was: %T`, configRepositoriesAttribute))
	}

	externalBackendsAttribute, ok := attributes["external_backends"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_backends is missing from object`)

		return nil, diags
	}

	externalBackendsVal, ok := externalBackendsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_backends expected to be basetypes.ListValue, was: %T`, externalBackendsAttribute))
	}

	serviceCatalogSourcesAttribute, ok := attributes["service_catalog_sources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_catalog_sources is missing from object`)

		return nil, diags
	}

	serviceCatalogSourcesVal, ok := serviceCatalogSourcesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_catalog_sources expected to be basetypes.ListValue, was: %T`, serviceCatalogSourcesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InUseValue{
		ConfigRepositories:    configRepositoriesVal,
		ExternalBackends:      externalBackendsVal,
		ServiceCatalogSources: serviceCatalogSourcesVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewInUseValueNull() InUseValue {
	return InUseValue{
		state: attr.ValueStateNull,
	}
}

func NewInUseValueUnknown() InUseValue {
	return InUseValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInUseValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InUseValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InUseValue Attribute Value",
				"While creating a InUseValue value, a missing attribute value was detected. "+
					"A InUseValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InUseValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InUseValue Attribute Type",
				"While creating a InUseValue value, an invalid attribute value was detected. "+
					"A InUseValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InUseValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InUseValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InUseValue Attribute Value",
				"While creating a InUseValue value, an extra attribute value was detected. "+
					"A InUseValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InUseValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInUseValueUnknown(), diags
	}

	configRepositoriesAttribute, ok := attributes["config_repositories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_repositories is missing from object`)

		return NewInUseValueUnknown(), diags
	}

	configRepositoriesVal, ok := configRepositoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_repositories expected to be basetypes.ListValue, was: %T`, configRepositoriesAttribute))
	}

	externalBackendsAttribute, ok := attributes["external_backends"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_backends is missing from object`)

		return NewInUseValueUnknown(), diags
	}

	externalBackendsVal, ok := externalBackendsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_backends expected to be basetypes.ListValue, was: %T`, externalBackendsAttribute))
	}

	serviceCatalogSourcesAttribute, ok := attributes["service_catalog_sources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_catalog_sources is missing from object`)

		return NewInUseValueUnknown(), diags
	}

	serviceCatalogSourcesVal, ok := serviceCatalogSourcesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_catalog_sources expected to be basetypes.ListValue, was: %T`, serviceCatalogSourcesAttribute))
	}

	if diags.HasError() {
		return NewInUseValueUnknown(), diags
	}

	return InUseValue{
		ConfigRepositories:    configRepositoriesVal,
		ExternalBackends:      externalBackendsVal,
		ServiceCatalogSources: serviceCatalogSourcesVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewInUseValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InUseValue {
	object, diags := NewInUseValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInUseValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InUseType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInUseValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInUseValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInUseValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInUseValueMust(InUseValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InUseType) ValueType(ctx context.Context) attr.Value {
	return InUseValue{}
}

var _ basetypes.ObjectValuable = InUseValue{}

type InUseValue struct {
	ConfigRepositories    basetypes.ListValue `tfsdk:"config_repositories"`
	ExternalBackends      basetypes.ListValue `tfsdk:"external_backends"`
	ServiceCatalogSources basetypes.ListValue `tfsdk:"service_catalog_sources"`
	state                 attr.ValueState
}

func (v InUseValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["config_repositories"] = basetypes.ListType{
		ElemType: ConfigRepositoriesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["external_backends"] = basetypes.ListType{
		ElemType: ExternalBackendsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_catalog_sources"] = basetypes.ListType{
		ElemType: ServiceCatalogSourcesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ConfigRepositories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_repositories"] = val

		val, err = v.ExternalBackends.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_backends"] = val

		val, err = v.ServiceCatalogSources.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_catalog_sources"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InUseValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InUseValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InUseValue) String() string {
	return "InUseValue"
}

func (v InUseValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	configRepositories := types.ListValueMust(
		ConfigRepositoriesType{
			basetypes.ObjectType{
				AttrTypes: ConfigRepositoriesValue{}.AttributeTypes(ctx),
			},
		},
		v.ConfigRepositories.Elements(),
	)

	if v.ConfigRepositories.IsNull() {
		configRepositories = types.ListNull(
			ConfigRepositoriesType{
				basetypes.ObjectType{
					AttrTypes: ConfigRepositoriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ConfigRepositories.IsUnknown() {
		configRepositories = types.ListUnknown(
			ConfigRepositoriesType{
				basetypes.ObjectType{
					AttrTypes: ConfigRepositoriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	externalBackends := types.ListValueMust(
		ExternalBackendsType{
			basetypes.ObjectType{
				AttrTypes: ExternalBackendsValue{}.AttributeTypes(ctx),
			},
		},
		v.ExternalBackends.Elements(),
	)

	if v.ExternalBackends.IsNull() {
		externalBackends = types.ListNull(
			ExternalBackendsType{
				basetypes.ObjectType{
					AttrTypes: ExternalBackendsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ExternalBackends.IsUnknown() {
		externalBackends = types.ListUnknown(
			ExternalBackendsType{
				basetypes.ObjectType{
					AttrTypes: ExternalBackendsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	serviceCatalogSources := types.ListValueMust(
		ServiceCatalogSourcesType{
			basetypes.ObjectType{
				AttrTypes: ServiceCatalogSourcesValue{}.AttributeTypes(ctx),
			},
		},
		v.ServiceCatalogSources.Elements(),
	)

	if v.ServiceCatalogSources.IsNull() {
		serviceCatalogSources = types.ListNull(
			ServiceCatalogSourcesType{
				basetypes.ObjectType{
					AttrTypes: ServiceCatalogSourcesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ServiceCatalogSources.IsUnknown() {
		serviceCatalogSources = types.ListUnknown(
			ServiceCatalogSourcesType{
				basetypes.ObjectType{
					AttrTypes: ServiceCatalogSourcesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"config_repositories": basetypes.ListType{
				ElemType: ConfigRepositoriesValue{}.Type(ctx),
			},
			"external_backends": basetypes.ListType{
				ElemType: ExternalBackendsValue{}.Type(ctx),
			},
			"service_catalog_sources": basetypes.ListType{
				ElemType: ServiceCatalogSourcesValue{}.Type(ctx),
			},
		},
		map[string]attr.Value{
			"config_repositories":     configRepositories,
			"external_backends":       externalBackends,
			"service_catalog_sources": serviceCatalogSources,
		})

	return objVal, diags
}

func (v InUseValue) Equal(o attr.Value) bool {
	other, ok := o.(InUseValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfigRepositories.Equal(other.ConfigRepositories) {
		return false
	}

	if !v.ExternalBackends.Equal(other.ExternalBackends) {
		return false
	}

	if !v.ServiceCatalogSources.Equal(other.ServiceCatalogSources) {
		return false
	}

	return true
}

func (v InUseValue) Type(ctx context.Context) attr.Type {
	return InUseType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InUseValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config_repositories": basetypes.ListType{
			ElemType: ConfigRepositoriesValue{}.Type(ctx),
		},
		"external_backends": basetypes.ListType{
			ElemType: ExternalBackendsValue{}.Type(ctx),
		},
		"service_catalog_sources": basetypes.ListType{
			ElemType: ServiceCatalogSourcesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigRepositoriesType{}

type ConfigRepositoriesType struct {
	basetypes.ObjectType
}

func (t ConfigRepositoriesType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigRepositoriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigRepositoriesType) String() string {
	return "ConfigRepositoriesType"
}

func (t ConfigRepositoriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigRepositoriesValue{
		Canonical: canonicalVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigRepositoriesValueNull() ConfigRepositoriesValue {
	return ConfigRepositoriesValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigRepositoriesValueUnknown() ConfigRepositoriesValue {
	return ConfigRepositoriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigRepositoriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigRepositoriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigRepositoriesValue Attribute Value",
				"While creating a ConfigRepositoriesValue value, a missing attribute value was detected. "+
					"A ConfigRepositoriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigRepositoriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigRepositoriesValue Attribute Type",
				"While creating a ConfigRepositoriesValue value, an invalid attribute value was detected. "+
					"A ConfigRepositoriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigRepositoriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigRepositoriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigRepositoriesValue Attribute Value",
				"While creating a ConfigRepositoriesValue value, an extra attribute value was detected. "+
					"A ConfigRepositoriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigRepositoriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigRepositoriesValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewConfigRepositoriesValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewConfigRepositoriesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewConfigRepositoriesValueUnknown(), diags
	}

	return ConfigRepositoriesValue{
		Canonical: canonicalVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigRepositoriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigRepositoriesValue {
	object, diags := NewConfigRepositoriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigRepositoriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigRepositoriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigRepositoriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigRepositoriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigRepositoriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigRepositoriesValueMust(ConfigRepositoriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigRepositoriesType) ValueType(ctx context.Context) attr.Value {
	return ConfigRepositoriesValue{}
}

var _ basetypes.ObjectValuable = ConfigRepositoriesValue{}

type ConfigRepositoriesValue struct {
	Canonical basetypes.StringValue `tfsdk:"canonical"`
	Name      basetypes.StringValue `tfsdk:"name"`
	state     attr.ValueState
}

func (v ConfigRepositoriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigRepositoriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigRepositoriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigRepositoriesValue) String() string {
	return "ConfigRepositoriesValue"
}

func (v ConfigRepositoriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"canonical": basetypes.StringType{},
			"name":      basetypes.StringType{},
		},
		map[string]attr.Value{
			"canonical": v.Canonical,
			"name":      v.Name,
		})

	return objVal, diags
}

func (v ConfigRepositoriesValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigRepositoriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ConfigRepositoriesValue) Type(ctx context.Context) attr.Type {
	return ConfigRepositoriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigRepositoriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical": basetypes.StringType{},
		"name":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExternalBackendsType{}

type ExternalBackendsType struct {
	basetypes.ObjectType
}

func (t ExternalBackendsType) Equal(o attr.Type) bool {
	other, ok := o.(ExternalBackendsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExternalBackendsType) String() string {
	return "ExternalBackendsType"
}

func (t ExternalBackendsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	engineAttribute, ok := attributes["engine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine is missing from object`)

		return nil, diags
	}

	engineVal, ok := engineAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine expected to be basetypes.StringValue, was: %T`, engineAttribute))
	}

	environmentAttribute, ok := attributes["environment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`environment is missing from object`)

		return nil, diags
	}

	environmentVal, ok := environmentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`environment expected to be basetypes.ObjectValue, was: %T`, environmentAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.ObjectValue, was: %T`, projectAttribute))
	}

	purposeAttribute, ok := attributes["purpose"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`purpose is missing from object`)

		return nil, diags
	}

	purposeVal, ok := purposeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`purpose expected to be basetypes.StringValue, was: %T`, purposeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExternalBackendsValue{
		Engine:      engineVal,
		Environment: environmentVal,
		Project:     projectVal,
		Purpose:     purposeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewExternalBackendsValueNull() ExternalBackendsValue {
	return ExternalBackendsValue{
		state: attr.ValueStateNull,
	}
}

func NewExternalBackendsValueUnknown() ExternalBackendsValue {
	return ExternalBackendsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExternalBackendsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExternalBackendsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExternalBackendsValue Attribute Value",
				"While creating a ExternalBackendsValue value, a missing attribute value was detected. "+
					"A ExternalBackendsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalBackendsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExternalBackendsValue Attribute Type",
				"While creating a ExternalBackendsValue value, an invalid attribute value was detected. "+
					"A ExternalBackendsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalBackendsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExternalBackendsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExternalBackendsValue Attribute Value",
				"While creating a ExternalBackendsValue value, an extra attribute value was detected. "+
					"A ExternalBackendsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExternalBackendsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExternalBackendsValueUnknown(), diags
	}

	engineAttribute, ok := attributes["engine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine is missing from object`)

		return NewExternalBackendsValueUnknown(), diags
	}

	engineVal, ok := engineAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine expected to be basetypes.StringValue, was: %T`, engineAttribute))
	}

	environmentAttribute, ok := attributes["environment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`environment is missing from object`)

		return NewExternalBackendsValueUnknown(), diags
	}

	environmentVal, ok := environmentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`environment expected to be basetypes.ObjectValue, was: %T`, environmentAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewExternalBackendsValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.ObjectValue, was: %T`, projectAttribute))
	}

	purposeAttribute, ok := attributes["purpose"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`purpose is missing from object`)

		return NewExternalBackendsValueUnknown(), diags
	}

	purposeVal, ok := purposeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`purpose expected to be basetypes.StringValue, was: %T`, purposeAttribute))
	}

	if diags.HasError() {
		return NewExternalBackendsValueUnknown(), diags
	}

	return ExternalBackendsValue{
		Engine:      engineVal,
		Environment: environmentVal,
		Project:     projectVal,
		Purpose:     purposeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewExternalBackendsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExternalBackendsValue {
	object, diags := NewExternalBackendsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExternalBackendsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExternalBackendsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExternalBackendsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExternalBackendsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExternalBackendsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExternalBackendsValueMust(ExternalBackendsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExternalBackendsType) ValueType(ctx context.Context) attr.Value {
	return ExternalBackendsValue{}
}

var _ basetypes.ObjectValuable = ExternalBackendsValue{}

type ExternalBackendsValue struct {
	Engine      basetypes.StringValue `tfsdk:"engine"`
	Environment basetypes.ObjectValue `tfsdk:"environment"`
	Project     basetypes.ObjectValue `tfsdk:"project"`
	Purpose     basetypes.StringValue `tfsdk:"purpose"`
	state       attr.ValueState
}

func (v ExternalBackendsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["engine"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["environment"] = basetypes.ObjectType{
		AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["project"] = basetypes.ObjectType{
		AttrTypes: ProjectValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["purpose"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Engine.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engine"] = val

		val, err = v.Environment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["environment"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		val, err = v.Purpose.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["purpose"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExternalBackendsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExternalBackendsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExternalBackendsValue) String() string {
	return "ExternalBackendsValue"
}

func (v ExternalBackendsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var environment basetypes.ObjectValue

	if v.Environment.IsNull() {
		environment = types.ObjectNull(
			EnvironmentValue{}.AttributeTypes(ctx),
		)
	}

	if v.Environment.IsUnknown() {
		environment = types.ObjectUnknown(
			EnvironmentValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Environment.IsNull() && !v.Environment.IsUnknown() {
		environment = types.ObjectValueMust(
			EnvironmentValue{}.AttributeTypes(ctx),
			v.Environment.Attributes(),
		)
	}

	var project basetypes.ObjectValue

	if v.Project.IsNull() {
		project = types.ObjectNull(
			ProjectValue{}.AttributeTypes(ctx),
		)
	}

	if v.Project.IsUnknown() {
		project = types.ObjectUnknown(
			ProjectValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Project.IsNull() && !v.Project.IsUnknown() {
		project = types.ObjectValueMust(
			ProjectValue{}.AttributeTypes(ctx),
			v.Project.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"engine": basetypes.StringType{},
			"environment": basetypes.ObjectType{
				AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
			},
			"project": basetypes.ObjectType{
				AttrTypes: ProjectValue{}.AttributeTypes(ctx),
			},
			"purpose": basetypes.StringType{},
		},
		map[string]attr.Value{
			"engine":      v.Engine,
			"environment": environment,
			"project":     project,
			"purpose":     v.Purpose,
		})

	return objVal, diags
}

func (v ExternalBackendsValue) Equal(o attr.Value) bool {
	other, ok := o.(ExternalBackendsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Engine.Equal(other.Engine) {
		return false
	}

	if !v.Environment.Equal(other.Environment) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	if !v.Purpose.Equal(other.Purpose) {
		return false
	}

	return true
}

func (v ExternalBackendsValue) Type(ctx context.Context) attr.Type {
	return ExternalBackendsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExternalBackendsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"engine": basetypes.StringType{},
		"environment": basetypes.ObjectType{
			AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
		},
		"project": basetypes.ObjectType{
			AttrTypes: ProjectValue{}.AttributeTypes(ctx),
		},
		"purpose": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EnvironmentType{}

type EnvironmentType struct {
	basetypes.ObjectType
}

func (t EnvironmentType) Equal(o attr.Type) bool {
	other, ok := o.(EnvironmentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EnvironmentType) String() string {
	return "EnvironmentType"
}

func (t EnvironmentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EnvironmentValue{
		Canonical: canonicalVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEnvironmentValueNull() EnvironmentValue {
	return EnvironmentValue{
		state: attr.ValueStateNull,
	}
}

func NewEnvironmentValueUnknown() EnvironmentValue {
	return EnvironmentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEnvironmentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EnvironmentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EnvironmentValue Attribute Value",
				"While creating a EnvironmentValue value, a missing attribute value was detected. "+
					"A EnvironmentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EnvironmentValue Attribute Type",
				"While creating a EnvironmentValue value, an invalid attribute value was detected. "+
					"A EnvironmentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EnvironmentValue Attribute Value",
				"While creating a EnvironmentValue value, an extra attribute value was detected. "+
					"A EnvironmentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EnvironmentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEnvironmentValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	if diags.HasError() {
		return NewEnvironmentValueUnknown(), diags
	}

	return EnvironmentValue{
		Canonical: canonicalVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEnvironmentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EnvironmentValue {
	object, diags := NewEnvironmentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEnvironmentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EnvironmentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEnvironmentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEnvironmentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEnvironmentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEnvironmentValueMust(EnvironmentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EnvironmentType) ValueType(ctx context.Context) attr.Value {
	return EnvironmentValue{}
}

var _ basetypes.ObjectValuable = EnvironmentValue{}

type EnvironmentValue struct {
	Canonical basetypes.StringValue `tfsdk:"canonical"`
	state     attr.ValueState
}

func (v EnvironmentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EnvironmentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EnvironmentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EnvironmentValue) String() string {
	return "EnvironmentValue"
}

func (v EnvironmentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"canonical": basetypes.StringType{},
		},
		map[string]attr.Value{
			"canonical": v.Canonical,
		})

	return objVal, diags
}

func (v EnvironmentValue) Equal(o attr.Value) bool {
	other, ok := o.(EnvironmentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	return true
}

func (v EnvironmentValue) Type(ctx context.Context) attr.Type {
	return EnvironmentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EnvironmentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ProjectType{}

type ProjectType struct {
	basetypes.ObjectType
}

func (t ProjectType) Equal(o attr.Type) bool {
	other, ok := o.(ProjectType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProjectType) String() string {
	return "ProjectType"
}

func (t ProjectType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProjectValue{
		Canonical: canonicalVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewProjectValueNull() ProjectValue {
	return ProjectValue{
		state: attr.ValueStateNull,
	}
}

func NewProjectValueUnknown() ProjectValue {
	return ProjectValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProjectValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProjectValue Attribute Value",
				"While creating a ProjectValue value, a missing attribute value was detected. "+
					"A ProjectValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProjectValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProjectValue Attribute Type",
				"While creating a ProjectValue value, an invalid attribute value was detected. "+
					"A ProjectValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProjectValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProjectValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProjectValue Attribute Value",
				"While creating a ProjectValue value, an extra attribute value was detected. "+
					"A ProjectValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProjectValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProjectValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewProjectValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewProjectValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewProjectValueUnknown(), diags
	}

	return ProjectValue{
		Canonical: canonicalVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewProjectValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProjectValue {
	object, diags := NewProjectValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProjectValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProjectType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProjectValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProjectValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProjectValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProjectValueMust(ProjectValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProjectType) ValueType(ctx context.Context) attr.Value {
	return ProjectValue{}
}

var _ basetypes.ObjectValuable = ProjectValue{}

type ProjectValue struct {
	Canonical basetypes.StringValue `tfsdk:"canonical"`
	Name      basetypes.StringValue `tfsdk:"name"`
	state     attr.ValueState
}

func (v ProjectValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProjectValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProjectValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProjectValue) String() string {
	return "ProjectValue"
}

func (v ProjectValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"canonical": basetypes.StringType{},
			"name":      basetypes.StringType{},
		},
		map[string]attr.Value{
			"canonical": v.Canonical,
			"name":      v.Name,
		})

	return objVal, diags
}

func (v ProjectValue) Equal(o attr.Value) bool {
	other, ok := o.(ProjectValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ProjectValue) Type(ctx context.Context) attr.Type {
	return ProjectType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProjectValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical": basetypes.StringType{},
		"name":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServiceCatalogSourcesType{}

type ServiceCatalogSourcesType struct {
	basetypes.ObjectType
}

func (t ServiceCatalogSourcesType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceCatalogSourcesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceCatalogSourcesType) String() string {
	return "ServiceCatalogSourcesType"
}

func (t ServiceCatalogSourcesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return nil, diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceCatalogSourcesValue{
		Canonical: canonicalVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewServiceCatalogSourcesValueNull() ServiceCatalogSourcesValue {
	return ServiceCatalogSourcesValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceCatalogSourcesValueUnknown() ServiceCatalogSourcesValue {
	return ServiceCatalogSourcesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceCatalogSourcesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceCatalogSourcesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceCatalogSourcesValue Attribute Value",
				"While creating a ServiceCatalogSourcesValue value, a missing attribute value was detected. "+
					"A ServiceCatalogSourcesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceCatalogSourcesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceCatalogSourcesValue Attribute Type",
				"While creating a ServiceCatalogSourcesValue value, an invalid attribute value was detected. "+
					"A ServiceCatalogSourcesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceCatalogSourcesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceCatalogSourcesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceCatalogSourcesValue Attribute Value",
				"While creating a ServiceCatalogSourcesValue value, an extra attribute value was detected. "+
					"A ServiceCatalogSourcesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceCatalogSourcesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceCatalogSourcesValueUnknown(), diags
	}

	canonicalAttribute, ok := attributes["canonical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canonical is missing from object`)

		return NewServiceCatalogSourcesValueUnknown(), diags
	}

	canonicalVal, ok := canonicalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canonical expected to be basetypes.StringValue, was: %T`, canonicalAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServiceCatalogSourcesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewServiceCatalogSourcesValueUnknown(), diags
	}

	return ServiceCatalogSourcesValue{
		Canonical: canonicalVal,
		Name:      nameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewServiceCatalogSourcesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceCatalogSourcesValue {
	object, diags := NewServiceCatalogSourcesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceCatalogSourcesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceCatalogSourcesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceCatalogSourcesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceCatalogSourcesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceCatalogSourcesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceCatalogSourcesValueMust(ServiceCatalogSourcesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceCatalogSourcesType) ValueType(ctx context.Context) attr.Value {
	return ServiceCatalogSourcesValue{}
}

var _ basetypes.ObjectValuable = ServiceCatalogSourcesValue{}

type ServiceCatalogSourcesValue struct {
	Canonical basetypes.StringValue `tfsdk:"canonical"`
	Name      basetypes.StringValue `tfsdk:"name"`
	state     attr.ValueState
}

func (v ServiceCatalogSourcesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["canonical"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Canonical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canonical"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceCatalogSourcesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceCatalogSourcesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceCatalogSourcesValue) String() string {
	return "ServiceCatalogSourcesValue"
}

func (v ServiceCatalogSourcesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"canonical": basetypes.StringType{},
			"name":      basetypes.StringType{},
		},
		map[string]attr.Value{
			"canonical": v.Canonical,
			"name":      v.Name,
		})

	return objVal, diags
}

func (v ServiceCatalogSourcesValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceCatalogSourcesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canonical.Equal(other.Canonical) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ServiceCatalogSourcesValue) Type(ctx context.Context) attr.Type {
	return ServiceCatalogSourcesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceCatalogSourcesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canonical": basetypes.StringType{},
		"name":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OwnerType{}

type OwnerType struct {
	basetypes.ObjectType
}

func (t OwnerType) Equal(o attr.Type) bool {
	other, ok := o.(OwnerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OwnerType) String() string {
	return "OwnerType"
}

func (t OwnerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return nil, diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.Int64Value, was: %T`, createdAtAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	familyNameAttribute, ok := attributes["family_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family_name is missing from object`)

		return nil, diags
	}

	familyNameVal, ok := familyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family_name expected to be basetypes.StringValue, was: %T`, familyNameAttribute))
	}

	givenNameAttribute, ok := attributes["given_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`given_name is missing from object`)

		return nil, diags
	}

	givenNameVal, ok := givenNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`given_name expected to be basetypes.StringValue, was: %T`, givenNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	lastLoginAtAttribute, ok := attributes["last_login_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_login_at is missing from object`)

		return nil, diags
	}

	lastLoginAtVal, ok := lastLoginAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_login_at expected to be basetypes.Int64Value, was: %T`, lastLoginAtAttribute))
	}

	localeAttribute, ok := attributes["locale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locale is missing from object`)

		return nil, diags
	}

	localeVal, ok := localeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locale expected to be basetypes.StringValue, was: %T`, localeAttribute))
	}

	mfaEnabledAttribute, ok := attributes["mfa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mfa_enabled is missing from object`)

		return nil, diags
	}

	mfaEnabledVal, ok := mfaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mfa_enabled expected to be basetypes.BoolValue, was: %T`, mfaEnabledAttribute))
	}

	pictureUrlAttribute, ok := attributes["picture_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`picture_url is missing from object`)

		return nil, diags
	}

	pictureUrlVal, ok := pictureUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`picture_url expected to be basetypes.StringValue, was: %T`, pictureUrlAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.Int64Value, was: %T`, updatedAtAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OwnerValue{
		CountryCode: countryCodeVal,
		CreatedAt:   createdAtVal,
		Email:       emailVal,
		FamilyName:  familyNameVal,
		GivenName:   givenNameVal,
		Id:          idVal,
		LastLoginAt: lastLoginAtVal,
		Locale:      localeVal,
		MfaEnabled:  mfaEnabledVal,
		PictureUrl:  pictureUrlVal,
		UpdatedAt:   updatedAtVal,
		Username:    usernameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOwnerValueNull() OwnerValue {
	return OwnerValue{
		state: attr.ValueStateNull,
	}
}

func NewOwnerValueUnknown() OwnerValue {
	return OwnerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOwnerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OwnerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OwnerValue Attribute Value",
				"While creating a OwnerValue value, a missing attribute value was detected. "+
					"A OwnerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OwnerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OwnerValue Attribute Type",
				"While creating a OwnerValue value, an invalid attribute value was detected. "+
					"A OwnerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OwnerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OwnerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OwnerValue Attribute Value",
				"While creating a OwnerValue value, an extra attribute value was detected. "+
					"A OwnerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OwnerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOwnerValueUnknown(), diags
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.Int64Value, was: %T`, createdAtAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	familyNameAttribute, ok := attributes["family_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family_name is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	familyNameVal, ok := familyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family_name expected to be basetypes.StringValue, was: %T`, familyNameAttribute))
	}

	givenNameAttribute, ok := attributes["given_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`given_name is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	givenNameVal, ok := givenNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`given_name expected to be basetypes.StringValue, was: %T`, givenNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	lastLoginAtAttribute, ok := attributes["last_login_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_login_at is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	lastLoginAtVal, ok := lastLoginAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_login_at expected to be basetypes.Int64Value, was: %T`, lastLoginAtAttribute))
	}

	localeAttribute, ok := attributes["locale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locale is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	localeVal, ok := localeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locale expected to be basetypes.StringValue, was: %T`, localeAttribute))
	}

	mfaEnabledAttribute, ok := attributes["mfa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mfa_enabled is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	mfaEnabledVal, ok := mfaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mfa_enabled expected to be basetypes.BoolValue, was: %T`, mfaEnabledAttribute))
	}

	pictureUrlAttribute, ok := attributes["picture_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`picture_url is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	pictureUrlVal, ok := pictureUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`picture_url expected to be basetypes.StringValue, was: %T`, pictureUrlAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.Int64Value, was: %T`, updatedAtAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewOwnerValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewOwnerValueUnknown(), diags
	}

	return OwnerValue{
		CountryCode: countryCodeVal,
		CreatedAt:   createdAtVal,
		Email:       emailVal,
		FamilyName:  familyNameVal,
		GivenName:   givenNameVal,
		Id:          idVal,
		LastLoginAt: lastLoginAtVal,
		Locale:      localeVal,
		MfaEnabled:  mfaEnabledVal,
		PictureUrl:  pictureUrlVal,
		UpdatedAt:   updatedAtVal,
		Username:    usernameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOwnerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OwnerValue {
	object, diags := NewOwnerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOwnerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OwnerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOwnerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOwnerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOwnerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOwnerValueMust(OwnerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OwnerType) ValueType(ctx context.Context) attr.Value {
	return OwnerValue{}
}

var _ basetypes.ObjectValuable = OwnerValue{}

type OwnerValue struct {
	CountryCode basetypes.StringValue `tfsdk:"country_code"`
	CreatedAt   basetypes.Int64Value  `tfsdk:"created_at"`
	Email       basetypes.StringValue `tfsdk:"email"`
	FamilyName  basetypes.StringValue `tfsdk:"family_name"`
	GivenName   basetypes.StringValue `tfsdk:"given_name"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	LastLoginAt basetypes.Int64Value  `tfsdk:"last_login_at"`
	Locale      basetypes.StringValue `tfsdk:"locale"`
	MfaEnabled  basetypes.BoolValue   `tfsdk:"mfa_enabled"`
	PictureUrl  basetypes.StringValue `tfsdk:"picture_url"`
	UpdatedAt   basetypes.Int64Value  `tfsdk:"updated_at"`
	Username    basetypes.StringValue `tfsdk:"username"`
	state       attr.ValueState
}

func (v OwnerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["country_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["family_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["given_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["last_login_at"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["locale"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mfa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["picture_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.CountryCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country_code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.FamilyName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family_name"] = val

		val, err = v.GivenName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["given_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.LastLoginAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_login_at"] = val

		val, err = v.Locale.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locale"] = val

		val, err = v.MfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mfa_enabled"] = val

		val, err = v.PictureUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["picture_url"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OwnerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OwnerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OwnerValue) String() string {
	return "OwnerValue"
}

func (v OwnerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"country_code":  basetypes.StringType{},
			"created_at":    basetypes.Int64Type{},
			"email":         basetypes.StringType{},
			"family_name":   basetypes.StringType{},
			"given_name":    basetypes.StringType{},
			"id":            basetypes.Int64Type{},
			"last_login_at": basetypes.Int64Type{},
			"locale":        basetypes.StringType{},
			"mfa_enabled":   basetypes.BoolType{},
			"picture_url":   basetypes.StringType{},
			"updated_at":    basetypes.Int64Type{},
			"username":      basetypes.StringType{},
		},
		map[string]attr.Value{
			"country_code":  v.CountryCode,
			"created_at":    v.CreatedAt,
			"email":         v.Email,
			"family_name":   v.FamilyName,
			"given_name":    v.GivenName,
			"id":            v.Id,
			"last_login_at": v.LastLoginAt,
			"locale":        v.Locale,
			"mfa_enabled":   v.MfaEnabled,
			"picture_url":   v.PictureUrl,
			"updated_at":    v.UpdatedAt,
			"username":      v.Username,
		})

	return objVal, diags
}

func (v OwnerValue) Equal(o attr.Value) bool {
	other, ok := o.(OwnerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CountryCode.Equal(other.CountryCode) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.FamilyName.Equal(other.FamilyName) {
		return false
	}

	if !v.GivenName.Equal(other.GivenName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.LastLoginAt.Equal(other.LastLoginAt) {
		return false
	}

	if !v.Locale.Equal(other.Locale) {
		return false
	}

	if !v.MfaEnabled.Equal(other.MfaEnabled) {
		return false
	}

	if !v.PictureUrl.Equal(other.PictureUrl) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v OwnerValue) Type(ctx context.Context) attr.Type {
	return OwnerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OwnerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"country_code":  basetypes.StringType{},
		"created_at":    basetypes.Int64Type{},
		"email":         basetypes.StringType{},
		"family_name":   basetypes.StringType{},
		"given_name":    basetypes.StringType{},
		"id":            basetypes.Int64Type{},
		"last_login_at": basetypes.Int64Type{},
		"locale":        basetypes.StringType{},
		"mfa_enabled":   basetypes.BoolType{},
		"picture_url":   basetypes.StringType{},
		"updated_at":    basetypes.Int64Type{},
		"username":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RawType{}

type RawType struct {
	basetypes.ObjectType
}

func (t RawType) Equal(o attr.Type) bool {
	other, ok := o.(RawType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RawType) String() string {
	return "RawType"
}

func (t RawType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessKeyAttribute, ok := attributes["access_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_key is missing from object`)

		return nil, diags
	}

	accessKeyVal, ok := accessKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_key expected to be basetypes.StringValue, was: %T`, accessKeyAttribute))
	}

	accountNameAttribute, ok := attributes["account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_name is missing from object`)

		return nil, diags
	}

	accountNameVal, ok := accountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_name expected to be basetypes.StringValue, was: %T`, accountNameAttribute))
	}

	authUrlAttribute, ok := attributes["auth_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_url is missing from object`)

		return nil, diags
	}

	authUrlVal, ok := authUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_url expected to be basetypes.StringValue, was: %T`, authUrlAttribute))
	}

	caCertAttribute, ok := attributes["ca_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ca_cert is missing from object`)

		return nil, diags
	}

	caCertVal, ok := caCertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ca_cert expected to be basetypes.StringValue, was: %T`, caCertAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return nil, diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	domainIdAttribute, ok := attributes["domain_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_id is missing from object`)

		return nil, diags
	}

	domainIdVal, ok := domainIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_id expected to be basetypes.StringValue, was: %T`, domainIdAttribute))
	}

	jsonKeyAttribute, ok := attributes["json_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`json_key is missing from object`)

		return nil, diags
	}

	jsonKeyVal, ok := jsonKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`json_key expected to be basetypes.StringValue, was: %T`, jsonKeyAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	rawAttribute, ok := attributes["raw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raw is missing from object`)

		return nil, diags
	}

	rawVal, ok := rawAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raw expected to be basetypes.ObjectValue, was: %T`, rawAttribute))
	}

	secretKeyAttribute, ok := attributes["secret_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret_key is missing from object`)

		return nil, diags
	}

	secretKeyVal, ok := secretKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret_key expected to be basetypes.StringValue, was: %T`, secretKeyAttribute))
	}

	sshKeyAttribute, ok := attributes["ssh_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_key is missing from object`)

		return nil, diags
	}

	sshKeyVal, ok := sshKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_key expected to be basetypes.StringValue, was: %T`, sshKeyAttribute))
	}

	subscriptionIdAttribute, ok := attributes["subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscription_id is missing from object`)

		return nil, diags
	}

	subscriptionIdVal, ok := subscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscription_id expected to be basetypes.StringValue, was: %T`, subscriptionIdAttribute))
	}

	tenantIdAttribute, ok := attributes["tenant_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_id is missing from object`)

		return nil, diags
	}

	tenantIdVal, ok := tenantIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_id expected to be basetypes.StringValue, was: %T`, tenantIdAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RawValue{
		AccessKey:      accessKeyVal,
		AccountName:    accountNameVal,
		AuthUrl:        authUrlVal,
		CaCert:         caCertVal,
		ClientId:       clientIdVal,
		ClientSecret:   clientSecretVal,
		DomainId:       domainIdVal,
		JsonKey:        jsonKeyVal,
		Password:       passwordVal,
		Raw:            rawVal,
		SecretKey:      secretKeyVal,
		SshKey:         sshKeyVal,
		SubscriptionId: subscriptionIdVal,
		TenantId:       tenantIdVal,
		Username:       usernameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRawValueNull() RawValue {
	return RawValue{
		state: attr.ValueStateNull,
	}
}

func NewRawValueUnknown() RawValue {
	return RawValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRawValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RawValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RawValue Attribute Value",
				"While creating a RawValue value, a missing attribute value was detected. "+
					"A RawValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RawValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RawValue Attribute Type",
				"While creating a RawValue value, an invalid attribute value was detected. "+
					"A RawValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RawValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RawValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RawValue Attribute Value",
				"While creating a RawValue value, an extra attribute value was detected. "+
					"A RawValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RawValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRawValueUnknown(), diags
	}

	accessKeyAttribute, ok := attributes["access_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_key is missing from object`)

		return NewRawValueUnknown(), diags
	}

	accessKeyVal, ok := accessKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_key expected to be basetypes.StringValue, was: %T`, accessKeyAttribute))
	}

	accountNameAttribute, ok := attributes["account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_name is missing from object`)

		return NewRawValueUnknown(), diags
	}

	accountNameVal, ok := accountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_name expected to be basetypes.StringValue, was: %T`, accountNameAttribute))
	}

	authUrlAttribute, ok := attributes["auth_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_url is missing from object`)

		return NewRawValueUnknown(), diags
	}

	authUrlVal, ok := authUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_url expected to be basetypes.StringValue, was: %T`, authUrlAttribute))
	}

	caCertAttribute, ok := attributes["ca_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ca_cert is missing from object`)

		return NewRawValueUnknown(), diags
	}

	caCertVal, ok := caCertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ca_cert expected to be basetypes.StringValue, was: %T`, caCertAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewRawValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return NewRawValueUnknown(), diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	domainIdAttribute, ok := attributes["domain_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_id is missing from object`)

		return NewRawValueUnknown(), diags
	}

	domainIdVal, ok := domainIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_id expected to be basetypes.StringValue, was: %T`, domainIdAttribute))
	}

	jsonKeyAttribute, ok := attributes["json_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`json_key is missing from object`)

		return NewRawValueUnknown(), diags
	}

	jsonKeyVal, ok := jsonKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`json_key expected to be basetypes.StringValue, was: %T`, jsonKeyAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewRawValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	rawAttribute, ok := attributes["raw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raw is missing from object`)

		return NewRawValueUnknown(), diags
	}

	rawVal, ok := rawAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raw expected to be basetypes.ObjectValue, was: %T`, rawAttribute))
	}

	secretKeyAttribute, ok := attributes["secret_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret_key is missing from object`)

		return NewRawValueUnknown(), diags
	}

	secretKeyVal, ok := secretKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret_key expected to be basetypes.StringValue, was: %T`, secretKeyAttribute))
	}

	sshKeyAttribute, ok := attributes["ssh_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_key is missing from object`)

		return NewRawValueUnknown(), diags
	}

	sshKeyVal, ok := sshKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_key expected to be basetypes.StringValue, was: %T`, sshKeyAttribute))
	}

	subscriptionIdAttribute, ok := attributes["subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscription_id is missing from object`)

		return NewRawValueUnknown(), diags
	}

	subscriptionIdVal, ok := subscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscription_id expected to be basetypes.StringValue, was: %T`, subscriptionIdAttribute))
	}

	tenantIdAttribute, ok := attributes["tenant_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_id is missing from object`)

		return NewRawValueUnknown(), diags
	}

	tenantIdVal, ok := tenantIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_id expected to be basetypes.StringValue, was: %T`, tenantIdAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewRawValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewRawValueUnknown(), diags
	}

	return RawValue{
		AccessKey:      accessKeyVal,
		AccountName:    accountNameVal,
		AuthUrl:        authUrlVal,
		CaCert:         caCertVal,
		ClientId:       clientIdVal,
		ClientSecret:   clientSecretVal,
		DomainId:       domainIdVal,
		JsonKey:        jsonKeyVal,
		Password:       passwordVal,
		Raw:            rawVal,
		SecretKey:      secretKeyVal,
		SshKey:         sshKeyVal,
		SubscriptionId: subscriptionIdVal,
		TenantId:       tenantIdVal,
		Username:       usernameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRawValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RawValue {
	object, diags := NewRawValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRawValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RawType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRawValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRawValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRawValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRawValueMust(RawValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RawType) ValueType(ctx context.Context) attr.Value {
	return RawValue{}
}

var _ basetypes.ObjectValuable = RawValue{}

type RawValue struct {
	AccessKey      basetypes.StringValue `tfsdk:"access_key"`
	AccountName    basetypes.StringValue `tfsdk:"account_name"`
	AuthUrl        basetypes.StringValue `tfsdk:"auth_url"`
	CaCert         basetypes.StringValue `tfsdk:"ca_cert"`
	ClientId       basetypes.StringValue `tfsdk:"client_id"`
	ClientSecret   basetypes.StringValue `tfsdk:"client_secret"`
	DomainId       basetypes.StringValue `tfsdk:"domain_id"`
	JsonKey        basetypes.StringValue `tfsdk:"json_key"`
	Password       basetypes.StringValue `tfsdk:"password"`
	Raw            basetypes.ObjectValue `tfsdk:"raw"`
	SecretKey      basetypes.StringValue `tfsdk:"secret_key"`
	SshKey         basetypes.StringValue `tfsdk:"ssh_key"`
	SubscriptionId basetypes.StringValue `tfsdk:"subscription_id"`
	TenantId       basetypes.StringValue `tfsdk:"tenant_id"`
	Username       basetypes.StringValue `tfsdk:"username"`
	state          attr.ValueState
}

func (v RawValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["access_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["account_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auth_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ca_cert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["domain_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["json_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["raw"] = basetypes.ObjectType{
		AttrTypes: RawValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["secret_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssh_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subscription_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.AccessKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_key"] = val

		val, err = v.AccountName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_name"] = val

		val, err = v.AuthUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_url"] = val

		val, err = v.CaCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ca_cert"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.ClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_secret"] = val

		val, err = v.DomainId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain_id"] = val

		val, err = v.JsonKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["json_key"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Raw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["raw"] = val

		val, err = v.SecretKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret_key"] = val

		val, err = v.SshKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh_key"] = val

		val, err = v.SubscriptionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subscription_id"] = val

		val, err = v.TenantId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_id"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RawValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RawValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RawValue) String() string {
	return "RawValue"
}

func (v RawValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var raw basetypes.ObjectValue

	if v.Raw.IsNull() {
		raw = types.ObjectNull(
			RawValue{}.AttributeTypes(ctx),
		)
	}

	if v.Raw.IsUnknown() {
		raw = types.ObjectUnknown(
			RawValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Raw.IsNull() && !v.Raw.IsUnknown() {
		raw = types.ObjectValueMust(
			RawValue{}.AttributeTypes(ctx),
			v.Raw.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"access_key":    basetypes.StringType{},
			"account_name":  basetypes.StringType{},
			"auth_url":      basetypes.StringType{},
			"ca_cert":       basetypes.StringType{},
			"client_id":     basetypes.StringType{},
			"client_secret": basetypes.StringType{},
			"domain_id":     basetypes.StringType{},
			"json_key":      basetypes.StringType{},
			"password":      basetypes.StringType{},
			"raw": basetypes.ObjectType{
				AttrTypes: RawValue{}.AttributeTypes(ctx),
			},
			"secret_key":      basetypes.StringType{},
			"ssh_key":         basetypes.StringType{},
			"subscription_id": basetypes.StringType{},
			"tenant_id":       basetypes.StringType{},
			"username":        basetypes.StringType{},
		},
		map[string]attr.Value{
			"access_key":      v.AccessKey,
			"account_name":    v.AccountName,
			"auth_url":        v.AuthUrl,
			"ca_cert":         v.CaCert,
			"client_id":       v.ClientId,
			"client_secret":   v.ClientSecret,
			"domain_id":       v.DomainId,
			"json_key":        v.JsonKey,
			"password":        v.Password,
			"raw":             raw,
			"secret_key":      v.SecretKey,
			"ssh_key":         v.SshKey,
			"subscription_id": v.SubscriptionId,
			"tenant_id":       v.TenantId,
			"username":        v.Username,
		})

	return objVal, diags
}

func (v RawValue) Equal(o attr.Value) bool {
	other, ok := o.(RawValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessKey.Equal(other.AccessKey) {
		return false
	}

	if !v.AccountName.Equal(other.AccountName) {
		return false
	}

	if !v.AuthUrl.Equal(other.AuthUrl) {
		return false
	}

	if !v.CaCert.Equal(other.CaCert) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.ClientSecret.Equal(other.ClientSecret) {
		return false
	}

	if !v.DomainId.Equal(other.DomainId) {
		return false
	}

	if !v.JsonKey.Equal(other.JsonKey) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Raw.Equal(other.Raw) {
		return false
	}

	if !v.SecretKey.Equal(other.SecretKey) {
		return false
	}

	if !v.SshKey.Equal(other.SshKey) {
		return false
	}

	if !v.SubscriptionId.Equal(other.SubscriptionId) {
		return false
	}

	if !v.TenantId.Equal(other.TenantId) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v RawValue) Type(ctx context.Context) attr.Type {
	return RawType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RawValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_key":    basetypes.StringType{},
		"account_name":  basetypes.StringType{},
		"auth_url":      basetypes.StringType{},
		"ca_cert":       basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"client_secret": basetypes.StringType{},
		"domain_id":     basetypes.StringType{},
		"json_key":      basetypes.StringType{},
		"password":      basetypes.StringType{},
		"raw": basetypes.ObjectType{
			AttrTypes: RawValue{}.AttributeTypes(ctx),
		},
		"secret_key":      basetypes.StringType{},
		"ssh_key":         basetypes.StringType{},
		"subscription_id": basetypes.StringType{},
		"tenant_id":       basetypes.StringType{},
		"username":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RawType{}

type RawType struct {
	basetypes.ObjectType
}

func (t RawType) Equal(o attr.Type) bool {
	other, ok := o.(RawType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RawType) String() string {
	return "RawType"
}

func (t RawType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return RawValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewRawValueNull() RawValue {
	return RawValue{
		state: attr.ValueStateNull,
	}
}

func NewRawValueUnknown() RawValue {
	return RawValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRawValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RawValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RawValue Attribute Value",
				"While creating a RawValue value, a missing attribute value was detected. "+
					"A RawValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RawValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RawValue Attribute Type",
				"While creating a RawValue value, an invalid attribute value was detected. "+
					"A RawValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RawValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RawValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RawValue Attribute Value",
				"While creating a RawValue value, an extra attribute value was detected. "+
					"A RawValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RawValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRawValueUnknown(), diags
	}

	if diags.HasError() {
		return NewRawValueUnknown(), diags
	}

	return RawValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewRawValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RawValue {
	object, diags := NewRawValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRawValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RawType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRawValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRawValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRawValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRawValueMust(RawValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RawType) ValueType(ctx context.Context) attr.Value {
	return RawValue{}
}

var _ basetypes.ObjectValuable = RawValue{}

type RawValue struct {
	state attr.ValueState
}

func (v RawValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RawValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RawValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RawValue) String() string {
	return "RawValue"
}

func (v RawValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{},
		map[string]attr.Value{})

	return objVal, diags
}

func (v RawValue) Equal(o attr.Value) bool {
	other, ok := o.(RawValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v RawValue) Type(ctx context.Context) attr.Type {
	return RawType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RawValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = RawType{}

type RawType struct {
	basetypes.ObjectType
}

func (t RawType) Equal(o attr.Type) bool {
	other, ok := o.(RawType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RawType) String() string {
	return "RawType"
}

func (t RawType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessKeyAttribute, ok := attributes["access_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_key is missing from object`)

		return nil, diags
	}

	accessKeyVal, ok := accessKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_key expected to be basetypes.StringValue, was: %T`, accessKeyAttribute))
	}

	accountNameAttribute, ok := attributes["account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_name is missing from object`)

		return nil, diags
	}

	accountNameVal, ok := accountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_name expected to be basetypes.StringValue, was: %T`, accountNameAttribute))
	}

	authUrlAttribute, ok := attributes["auth_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_url is missing from object`)

		return nil, diags
	}

	authUrlVal, ok := authUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_url expected to be basetypes.StringValue, was: %T`, authUrlAttribute))
	}

	caCertAttribute, ok := attributes["ca_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ca_cert is missing from object`)

		return nil, diags
	}

	caCertVal, ok := caCertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ca_cert expected to be basetypes.StringValue, was: %T`, caCertAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return nil, diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	domainIdAttribute, ok := attributes["domain_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_id is missing from object`)

		return nil, diags
	}

	domainIdVal, ok := domainIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_id expected to be basetypes.StringValue, was: %T`, domainIdAttribute))
	}

	jsonKeyAttribute, ok := attributes["json_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`json_key is missing from object`)

		return nil, diags
	}

	jsonKeyVal, ok := jsonKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`json_key expected to be basetypes.StringValue, was: %T`, jsonKeyAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	rawAttribute, ok := attributes["raw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raw is missing from object`)

		return nil, diags
	}

	rawVal, ok := rawAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raw expected to be basetypes.ObjectValue, was: %T`, rawAttribute))
	}

	secretKeyAttribute, ok := attributes["secret_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret_key is missing from object`)

		return nil, diags
	}

	secretKeyVal, ok := secretKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret_key expected to be basetypes.StringValue, was: %T`, secretKeyAttribute))
	}

	sshKeyAttribute, ok := attributes["ssh_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_key is missing from object`)

		return nil, diags
	}

	sshKeyVal, ok := sshKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_key expected to be basetypes.StringValue, was: %T`, sshKeyAttribute))
	}

	subscriptionIdAttribute, ok := attributes["subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscription_id is missing from object`)

		return nil, diags
	}

	subscriptionIdVal, ok := subscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscription_id expected to be basetypes.StringValue, was: %T`, subscriptionIdAttribute))
	}

	tenantIdAttribute, ok := attributes["tenant_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_id is missing from object`)

		return nil, diags
	}

	tenantIdVal, ok := tenantIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_id expected to be basetypes.StringValue, was: %T`, tenantIdAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RawValue{
		AccessKey:      accessKeyVal,
		AccountName:    accountNameVal,
		AuthUrl:        authUrlVal,
		CaCert:         caCertVal,
		ClientId:       clientIdVal,
		ClientSecret:   clientSecretVal,
		DomainId:       domainIdVal,
		JsonKey:        jsonKeyVal,
		Password:       passwordVal,
		Raw:            rawVal,
		SecretKey:      secretKeyVal,
		SshKey:         sshKeyVal,
		SubscriptionId: subscriptionIdVal,
		TenantId:       tenantIdVal,
		Username:       usernameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRawValueNull() RawValue {
	return RawValue{
		state: attr.ValueStateNull,
	}
}

func NewRawValueUnknown() RawValue {
	return RawValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRawValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RawValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RawValue Attribute Value",
				"While creating a RawValue value, a missing attribute value was detected. "+
					"A RawValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RawValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RawValue Attribute Type",
				"While creating a RawValue value, an invalid attribute value was detected. "+
					"A RawValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RawValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RawValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RawValue Attribute Value",
				"While creating a RawValue value, an extra attribute value was detected. "+
					"A RawValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RawValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRawValueUnknown(), diags
	}

	accessKeyAttribute, ok := attributes["access_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_key is missing from object`)

		return NewRawValueUnknown(), diags
	}

	accessKeyVal, ok := accessKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_key expected to be basetypes.StringValue, was: %T`, accessKeyAttribute))
	}

	accountNameAttribute, ok := attributes["account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_name is missing from object`)

		return NewRawValueUnknown(), diags
	}

	accountNameVal, ok := accountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_name expected to be basetypes.StringValue, was: %T`, accountNameAttribute))
	}

	authUrlAttribute, ok := attributes["auth_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_url is missing from object`)

		return NewRawValueUnknown(), diags
	}

	authUrlVal, ok := authUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_url expected to be basetypes.StringValue, was: %T`, authUrlAttribute))
	}

	caCertAttribute, ok := attributes["ca_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ca_cert is missing from object`)

		return NewRawValueUnknown(), diags
	}

	caCertVal, ok := caCertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ca_cert expected to be basetypes.StringValue, was: %T`, caCertAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewRawValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return NewRawValueUnknown(), diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	domainIdAttribute, ok := attributes["domain_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_id is missing from object`)

		return NewRawValueUnknown(), diags
	}

	domainIdVal, ok := domainIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_id expected to be basetypes.StringValue, was: %T`, domainIdAttribute))
	}

	jsonKeyAttribute, ok := attributes["json_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`json_key is missing from object`)

		return NewRawValueUnknown(), diags
	}

	jsonKeyVal, ok := jsonKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`json_key expected to be basetypes.StringValue, was: %T`, jsonKeyAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewRawValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	rawAttribute, ok := attributes["raw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raw is missing from object`)

		return NewRawValueUnknown(), diags
	}

	rawVal, ok := rawAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raw expected to be basetypes.ObjectValue, was: %T`, rawAttribute))
	}

	secretKeyAttribute, ok := attributes["secret_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret_key is missing from object`)

		return NewRawValueUnknown(), diags
	}

	secretKeyVal, ok := secretKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret_key expected to be basetypes.StringValue, was: %T`, secretKeyAttribute))
	}

	sshKeyAttribute, ok := attributes["ssh_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_key is missing from object`)

		return NewRawValueUnknown(), diags
	}

	sshKeyVal, ok := sshKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_key expected to be basetypes.StringValue, was: %T`, sshKeyAttribute))
	}

	subscriptionIdAttribute, ok := attributes["subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscription_id is missing from object`)

		return NewRawValueUnknown(), diags
	}

	subscriptionIdVal, ok := subscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscription_id expected to be basetypes.StringValue, was: %T`, subscriptionIdAttribute))
	}

	tenantIdAttribute, ok := attributes["tenant_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_id is missing from object`)

		return NewRawValueUnknown(), diags
	}

	tenantIdVal, ok := tenantIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_id expected to be basetypes.StringValue, was: %T`, tenantIdAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewRawValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewRawValueUnknown(), diags
	}

	return RawValue{
		AccessKey:      accessKeyVal,
		AccountName:    accountNameVal,
		AuthUrl:        authUrlVal,
		CaCert:         caCertVal,
		ClientId:       clientIdVal,
		ClientSecret:   clientSecretVal,
		DomainId:       domainIdVal,
		JsonKey:        jsonKeyVal,
		Password:       passwordVal,
		Raw:            rawVal,
		SecretKey:      secretKeyVal,
		SshKey:         sshKeyVal,
		SubscriptionId: subscriptionIdVal,
		TenantId:       tenantIdVal,
		Username:       usernameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRawValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RawValue {
	object, diags := NewRawValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRawValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RawType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRawValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRawValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRawValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRawValueMust(RawValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RawType) ValueType(ctx context.Context) attr.Value {
	return RawValue{}
}

var _ basetypes.ObjectValuable = RawValue{}

type RawValue struct {
	AccessKey      basetypes.StringValue `tfsdk:"access_key"`
	AccountName    basetypes.StringValue `tfsdk:"account_name"`
	AuthUrl        basetypes.StringValue `tfsdk:"auth_url"`
	CaCert         basetypes.StringValue `tfsdk:"ca_cert"`
	ClientId       basetypes.StringValue `tfsdk:"client_id"`
	ClientSecret   basetypes.StringValue `tfsdk:"client_secret"`
	DomainId       basetypes.StringValue `tfsdk:"domain_id"`
	JsonKey        basetypes.StringValue `tfsdk:"json_key"`
	Password       basetypes.StringValue `tfsdk:"password"`
	Raw            basetypes.ObjectValue `tfsdk:"raw"`
	SecretKey      basetypes.StringValue `tfsdk:"secret_key"`
	SshKey         basetypes.StringValue `tfsdk:"ssh_key"`
	SubscriptionId basetypes.StringValue `tfsdk:"subscription_id"`
	TenantId       basetypes.StringValue `tfsdk:"tenant_id"`
	Username       basetypes.StringValue `tfsdk:"username"`
	state          attr.ValueState
}

func (v RawValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["access_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["account_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auth_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ca_cert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["domain_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["json_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["raw"] = basetypes.ObjectType{
		AttrTypes: RawValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["secret_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssh_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subscription_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.AccessKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_key"] = val

		val, err = v.AccountName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_name"] = val

		val, err = v.AuthUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_url"] = val

		val, err = v.CaCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ca_cert"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.ClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_secret"] = val

		val, err = v.DomainId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain_id"] = val

		val, err = v.JsonKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["json_key"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Raw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["raw"] = val

		val, err = v.SecretKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret_key"] = val

		val, err = v.SshKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh_key"] = val

		val, err = v.SubscriptionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subscription_id"] = val

		val, err = v.TenantId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_id"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RawValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RawValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RawValue) String() string {
	return "RawValue"
}

func (v RawValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var raw basetypes.ObjectValue

	if v.Raw.IsNull() {
		raw = types.ObjectNull(
			RawValue{}.AttributeTypes(ctx),
		)
	}

	if v.Raw.IsUnknown() {
		raw = types.ObjectUnknown(
			RawValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Raw.IsNull() && !v.Raw.IsUnknown() {
		raw = types.ObjectValueMust(
			RawValue{}.AttributeTypes(ctx),
			v.Raw.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"access_key":    basetypes.StringType{},
			"account_name":  basetypes.StringType{},
			"auth_url":      basetypes.StringType{},
			"ca_cert":       basetypes.StringType{},
			"client_id":     basetypes.StringType{},
			"client_secret": basetypes.StringType{},
			"domain_id":     basetypes.StringType{},
			"json_key":      basetypes.StringType{},
			"password":      basetypes.StringType{},
			"raw": basetypes.ObjectType{
				AttrTypes: RawValue{}.AttributeTypes(ctx),
			},
			"secret_key":      basetypes.StringType{},
			"ssh_key":         basetypes.StringType{},
			"subscription_id": basetypes.StringType{},
			"tenant_id":       basetypes.StringType{},
			"username":        basetypes.StringType{},
		},
		map[string]attr.Value{
			"access_key":      v.AccessKey,
			"account_name":    v.AccountName,
			"auth_url":        v.AuthUrl,
			"ca_cert":         v.CaCert,
			"client_id":       v.ClientId,
			"client_secret":   v.ClientSecret,
			"domain_id":       v.DomainId,
			"json_key":        v.JsonKey,
			"password":        v.Password,
			"raw":             raw,
			"secret_key":      v.SecretKey,
			"ssh_key":         v.SshKey,
			"subscription_id": v.SubscriptionId,
			"tenant_id":       v.TenantId,
			"username":        v.Username,
		})

	return objVal, diags
}

func (v RawValue) Equal(o attr.Value) bool {
	other, ok := o.(RawValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessKey.Equal(other.AccessKey) {
		return false
	}

	if !v.AccountName.Equal(other.AccountName) {
		return false
	}

	if !v.AuthUrl.Equal(other.AuthUrl) {
		return false
	}

	if !v.CaCert.Equal(other.CaCert) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.ClientSecret.Equal(other.ClientSecret) {
		return false
	}

	if !v.DomainId.Equal(other.DomainId) {
		return false
	}

	if !v.JsonKey.Equal(other.JsonKey) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Raw.Equal(other.Raw) {
		return false
	}

	if !v.SecretKey.Equal(other.SecretKey) {
		return false
	}

	if !v.SshKey.Equal(other.SshKey) {
		return false
	}

	if !v.SubscriptionId.Equal(other.SubscriptionId) {
		return false
	}

	if !v.TenantId.Equal(other.TenantId) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v RawValue) Type(ctx context.Context) attr.Type {
	return RawType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RawValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_key":    basetypes.StringType{},
		"account_name":  basetypes.StringType{},
		"auth_url":      basetypes.StringType{},
		"ca_cert":       basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"client_secret": basetypes.StringType{},
		"domain_id":     basetypes.StringType{},
		"json_key":      basetypes.StringType{},
		"password":      basetypes.StringType{},
		"raw": basetypes.ObjectType{
			AttrTypes: RawValue{}.AttributeTypes(ctx),
		},
		"secret_key":      basetypes.StringType{},
		"ssh_key":         basetypes.StringType{},
		"subscription_id": basetypes.StringType{},
		"tenant_id":       basetypes.StringType{},
		"username":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RawType{}

type RawType struct {
	basetypes.ObjectType
}

func (t RawType) Equal(o attr.Type) bool {
	other, ok := o.(RawType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RawType) String() string {
	return "RawType"
}

func (t RawType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return RawValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewRawValueNull() RawValue {
	return RawValue{
		state: attr.ValueStateNull,
	}
}

func NewRawValueUnknown() RawValue {
	return RawValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRawValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RawValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RawValue Attribute Value",
				"While creating a RawValue value, a missing attribute value was detected. "+
					"A RawValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RawValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RawValue Attribute Type",
				"While creating a RawValue value, an invalid attribute value was detected. "+
					"A RawValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RawValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RawValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RawValue Attribute Value",
				"While creating a RawValue value, an extra attribute value was detected. "+
					"A RawValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RawValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRawValueUnknown(), diags
	}

	if diags.HasError() {
		return NewRawValueUnknown(), diags
	}

	return RawValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewRawValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RawValue {
	object, diags := NewRawValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRawValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RawType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRawValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRawValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRawValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRawValueMust(RawValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RawType) ValueType(ctx context.Context) attr.Value {
	return RawValue{}
}

var _ basetypes.ObjectValuable = RawValue{}

type RawValue struct {
	state attr.ValueState
}

func (v RawValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RawValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RawValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RawValue) String() string {
	return "RawValue"
}

func (v RawValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{},
		map[string]attr.Value{})

	return objVal, diags
}

func (v RawValue) Equal(o attr.Value) bool {
	other, ok := o.(RawValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v RawValue) Type(ctx context.Context) attr.Type {
	return RawType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RawValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
